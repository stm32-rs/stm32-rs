TIM[1-58]:
  CR1:
    CMS:
      EdgeAligned: [0, "The counter counts up or down depending on the direction bit"]
      CenterAligned1: [1, "The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down."]
      CenterAligned2: [2, "The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up."]
      CenterAligned3: [3, "The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down."]
    DIR:
      Up: [0, "Counter used as upcounter"]
      Down: [1, "Counter used as downcounter"]
  SMCR:
    ETP:
      NotInverted: [0, "ETR is noninverted, active at high level or rising edge"]
      Inverted: [1, "ETR is inverted, active at low level or falling edge"]
    ECE:
      Disabled: [0, "TIM[1-58]:[1-58]:ternal clock mode 2 disabled"]
      Enabled: [1, "External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal."]
    ETPS:
      Div1: [0, "Prescaler OFF"]
      Div2: [1, "ETRP frequency divided by 2"]
      Div4: [2, "ETRP frequency divided by 4"]
      Div8: [3, "ETRP frequency divided by 8"]
    ETF:
      NoFilter: [0, "No filter, sampling is done at fDTS"]
      FCK_INT_N2: [1, "fSAMPLING=fCK_INT, N=2"]
      FCK_INT_N4: [2, "fSAMPLING=fCK_INT, N=4"]
      FCK_INT_N8: [3, "fSAMPLING=fCK_INT, N=8"]
      FDTS_Div2_N6: [4, "fSAMPLING=fDTS/2, N=6"]
      FDTS_Div2_N8: [5, "fSAMPLING=fDTS/2, N=8"]
      FDTS_Div4_N6: [6, "fSAMPLING=fDTS/4, N=6"]
      FDTS_Div4_N8: [7, "fSAMPLING=fDTS/4, N=8"]
      FDTS_Div8_N6: [8, "fSAMPLING=fDTS/8, N=6"]
      FDTS_Div8_N8: [9, "fSAMPLING=fDTS/8, N=8"]
      FDTS_Div16_N5: [10, "fSAMPLING=fDTS/16, N=5"]
      FDTS_Div16_N6: [11, "fSAMPLING=fDTS/16, N=6"]
      FDTS_Div16_N8: [12, "fSAMPLING=fDTS/16, N=8"]
      FDTS_Div32_N5: [13, "fSAMPLING=fDTS/32, N=5"]
      FDTS_Div32_N6: [14, "fSAMPLING=fDTS/32, N=6"]
      FDTS_Div32_N8: [15, "fSAMPLING=fDTS/32, N=8"]
  CCMR2_Input:
    CC?S:
      TI3: [1, "Channel is configured as input, ICx is mapped on TI3"]
      TI4: [2, "Channel is configured as input, ICx is mapped on TI4"]
      TRC: [3, "Channel is configured as input, ICx is mapped on TRC"]

TIM[18]:
  CR2:
    MMS2:
      "Reset": [0b0000, "Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO2). If the reset is generated by the trigger input (slave mode controller configured in reset mode), the signal on TRGO2 is delayed compared to the actual reset"]
      Enable: [0b0001, "Enable - the Counter Enable signal CNT_EN is used as trigger output (TRGO2). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic AND between the CEN control bit and the trigger input when configured in Gated mode. When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO2, except if the Master/Slave mode is selected (see the MSM bit description in TIMx_SMCR register)"]
      Update: [0b0010, "Update - the update event is selected as trigger output (TRGO2). For instance, a master timer can then be used as a prescaler for a slave timer"]
      ComparePulse: [0b0011, "Compare pulse - the trigger output sends a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or compare match occurs (TRGO2)"]
      CompareOC1: [0b0100, "Compare - OC1REFC signal is used as trigger output (TRGO2)"]
      CompareOC2: [0b0101, "Compare - OC2REFC signal is used as trigger output (TRGO2)"]
      CompareOC3: [0b0110, "CompareCCMR[12]_Output:CCMR[12]_Output: - OC3REFC signal is used as trigger output (TRGO2)"]
      CompareOC4: [0b0111, "Compare - OC4REFC signal is used as trigger output (TRGO2)"]
      CompareOC5: [0b1000, "Compare - OC5REFC signal is used as trigger output (TRGO2)"]
      CompareOC6: [0b1001, "Compare - OC6REFC signal is used as trigger output (TRGO2)"]
      PulseOC4: [0b1010, "Compare Pulse - OC4REFC rising or falling edges generate pulses on TRGO2"]
      PulseOC6: [0b1011, "Compare Pulse - OC6REFC rising or falling edges generate pulses on TRGO2"]
      RisingOC4_6: [0b1100, "Compare Pulse - OC4REFC or OC6REFC rising edges generate pulses on TRGO2"]
      RisingOC4_FallingOC6: [0b1101, "Compare Pulse - OC4REFC rising or OC6REFC falling edges generate pulses on TRGO2"]
      RisingOC5_6: [0b1110, "Compare Pulse - OC5REFC or OC6REFC rising edges generate pulses on TRGO2"]
      RisingOC5_FallingOC6: [0b1111, "Compare Pulse - OC5REFC rising or OC6REFC falling edges generate pulses on TRGO2"]
  SR:
    B2IF:
      _read:
        NoTrigger: [0, "No break event occurred"]
        Trigger: [1, "An active level has been detected on the break 2 input. An interrupt is generated if BIE=1 in the TIMx_DIER register"]
      _write:
        Clear: [0, "Clear flag"]
    SBIF:
      _read:
        NoTrigger: [0, "No break event occurred"]
        Trigger: [1, "An active level has been detected on the system break input. An interrupt is generated if BIE=1 in the TIMx_DIER register"]
      _write:
        Clear: [0, "Clear flag"]
  EGR:
    B2G:
      _write:
        Trigger: [1, "A break 2 event is generated. MOE bit is cleared and B2IF flag is set. Related interrupt can occur if enabled"]
  BDTR:
    BK2BID:
      Input: [0, "Break input BRK2 in input mode"]
      Bidirectional: [1, "Break input BRK2 in bidirectional mode"]
    BK2DSRM:
      Armed: [0, "Break input BRK2 is armed"]
      Disarmed: [1, "Break input BRK2 is disarmed"]
    BK2P:
      Low: [0, "Break input BRK2 is active low"]
      High: [1, "Break input BRK2 is active high"]
    BK2E:
      Disabled: [0, "Break function disabled"]
      Enabled: [1, "Break function enabled"]
    BK2F:
      NoFilter: [0, "No filter, sampling is done at fDTS"]
      FCK_INT_N2: [1, "fSAMPLING=fCK_INT, N=2"]
      FCK_INT_N4: [2, "fSAMPLING=fCK_INT, N=4"]
      FCK_INT_N8: [3, "fSAMPLING=fCK_INT, N=8"]
      FDTS_Div2_N6: [4, "fSAMPLING=fDTS/2, N=6"]
      FDTS_Div2_N8: [5, "fSAMPLING=fDTS/2, N=8"]
      FDTS_Div4_N6: [6, "fSAMPLING=fDTS/4, N=6"]
      FDTS_Div4_N8: [7, "fSAMPLING=fDTS/4, N=8"]
      FDTS_Div8_N6: [8, "fSAMPLING=fDTS/8, N=6"]
      FDTS_Div8_N8: [9, "fSAMPLING=fDTS/8, N=8"]
      FDTS_Div16_N5: [10, "fSAMPLING=fDTS/16, N=5"]
      FDTS_Div16_N6: [11, "fSAMPLING=fDTS/16, N=6"]
      FDTS_Div16_N8: [12, "fSAMPLING=fDTS/16, N=8"]
      FDTS_Div32_N5: [13, "fSAMPLING=fDTS/32, N=5"]
      FDTS_Div32_N6: [14, "fSAMPLING=fDTS/32, N=6"]
      FDTS_Div32_N8: [15, "fSAMPLING=fDTS/32, N=8"]
  CCR5:
    GC5C3:
      Disabled: [0, "No effect of OC5REF on OC3REFC"]
      Enabled: [1, "OC3REFC is the logical AND of OC3REFC and OC5REF"]
    GC5C2:
      Disabled: [0, "No effect of OC5REF on OC2REFC"]
      Enabled: [1, "OC2REFC is the logical AND of OC2REFC and OC5REF"]
    GC5C1:
      Disabled: [0, "No effect of OC5REF on OC1REFC"]
      Enabled: [1, "OC1REFC is the logical AND of OC1REFC and OC5REF"]
  AF1:
    ETRSEL:
      IO: [0b0000, "ETR input is connected to I/O"]
      ADC1_AWD1: [0b0011, "ADC1 AWD1"]
      ADC1_AWD2: [0b0100, "ADC1 AWD2"]
      ADC1_AWD3: [0b0101, "ADC1 AWD3"]
      ADC2_AWD1: [0b0110, "ADC2 AWD1"]
      ADC2_AWD2: [0b0111, "ADC2 AWD2"]
      ADC2_AWD3: [0b1000, "ADC2 AWD3"]
  AF2:
    BK2INP:
      NotInverted: [0, 'Input polarity not inverted']
      Inverted: [1, 'Input polarity inverted']
    BK2INE:
      Disabled: [0, "BKIN input disabled"]
      Enabled: [1, "BKIN input enabled"]

TIM1,TIM15:
  AF1:
    BKDF1BK0E:
      Disabled: [0, "dfsdm1_break[0] input disabled"]
      Enabled: [1, "dfsdm1_break[0] input enabled"]
TIM1:
  AF2:
    BK2DF1BK1E:
      Disabled: [0, "dfsdm1_break[1] input disabled"]
      Enabled: [1, "dfsdm1_break[1] input enabled"]
TIM2:
  AF1:
    ETRSEL:
      IO: [0b0000, "ETR input is connected to I/O"]
      LSE: [0b0011, "LSE"]
      SAI1_FS_A: [0b0100, "SAI1 FS_A"]
      SAI1_FS_B: [0b0101, "SAI1 FS_B"]
      Eth_PTP_PPS_Out: [0b0110, "eth_ptp_pps_out"]
TIM3:
  AF1:
    ETRSEL:
      IO: [0b0000, "ETR input is connected to I/O"]
      Eth_PTP_PPS_Out: [0b0110, "eth_ptp_pps_out"]
TIM4:
  AF1:
    ETRSEL:
      IO: [0b0000, "ETR input is connected to I/O"]
      SAI1_FS_A: [0b0001, "SAI2 FS_A"]
      SAI1_FS_B: [0b0010, "SAI2 FS_B"]
      Eth_PTP_PPS_Out: [0b0011, "OTG_SOF"]
TIM5:
  AF1:
    ETRSEL:
      IO: [0b0000, "ETR input is connected to I/O"]
      SAI1_FS_A: [0b0001, "SAI2 FS_A"]
      SAI1_FS_B: [0b0010, "SAI2 FS_B"]
      Eth_PTP_PPS_Out: [0b0011, "OTG_SOF"]
TIM8,TIM16:
  AF1:
    BKDF1BK2E:
      Disabled: [0, "dfsdm1_break[2] input disabled"]
      Enabled: [1, "dfsdm1_break[2] input enabled"]

TIM[18],TIM1[5-7]:
  CR2:
    OIS?N:
      Disabled: [0, "OCxN=0 after a dead-time when MOE=0"]
      Enabled: [1, "OCxN=1 after a dead-time when MOE=0"]
    OIS?:
      Disabled: [0, "OCx=0 (after a dead-time if OCx(N) is implemented) when MOE=0"]
      Enabled: [1, "OCx=1 (after a dead-time if OCx(N) is implemented) when MOE=0"]
    CCUS:
      Bit: [0, "When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit only"]
      BitOrEdge: [1, "When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit or when an rising edge occurs on TRGI"]
    CCPC:
      NotPreloaded: [0, "CCxE, CCxNE and OCxM bits are not preloaded"]
      Preloaded: [1, "CCxE, CCxNE and OCxM bits are preloaded"]
  DIER:
    COMDE:
      Disabled: [0, "COM DMA request disabled"]
      Enabled: [1, "COM DMA request enabled"]
    BIE:
      Disabled: [0, "Break interrupt disabled"]
      Enabled: [1, "Break interrupt enabled"]
    COMIE:
      Disabled: [0, "COM interrupt disabled"]
      Enabled: [1, "COM interrupt enabled"]
  SR:
    BIF:
      _read:
        NoTrigger: [0, "No break event occurred"]
        Trigger: [1, "An active level has been detected on the break input. An interrupt is generated if BIE=1 in the TIMx_DIER register"]
      _write:
        Clear: [0, "Clear flag"]
    COMIF:
      _read:
        NoCOM: [0, "No COM event occurred"]
        COM: [1, "COM interrupt pending"]
      _write:
        Clear: [0, "Clear flag"]
  CCER:
    "CC?NE":
      Disabled: [0, "Complementary output disabled"]
      Enabled: [1, "Complementary output enabled"]
  RCR:
    REP: [0, 65535]
  BDTR:
    BKBID:
      Input: [0, "Break input BRK in input mode"]
      Bidirectional: [1, "Break input BRK in bidirectional mode"]
    BKDSRM:
      Armed: [0, "Break input BRK is armed"]
      Disarmed: [1, "Break input BRK is disarmed"]
    BKF:
      NoFilter: [0, "No filter, sampling is done at fDTS"]
      FCK_INT_N2: [1, "fSAMPLING=fCK_INT, N=2"]
      FCK_INT_N4: [2, "fSAMPLING=fCK_INT, N=4"]
      FCK_INT_N8: [3, "fSAMPLING=fCK_INT, N=8"]
      FDTS_Div2_N6: [4, "fSAMPLING=fDTS/2, N=6"]
      FDTS_Div2_N8: [5, "fSAMPLING=fDTS/2, N=8"]
      FDTS_Div4_N6: [6, "fSAMPLING=fDTS/4, N=6"]
      FDTS_Div4_N8: [7, "fSAMPLING=fDTS/4, N=8"]
      FDTS_Div8_N6: [8, "fSAMPLING=fDTS/8, N=6"]
      FDTS_Div8_N8: [9, "fSAMPLING=fDTS/8, N=8"]
      FDTS_Div16_N5: [10, "fSAMPLING=fDTS/16, N=5"]
      FDTS_Div16_N6: [11, "fSAMPLING=fDTS/16, N=6"]
      FDTS_Div16_N8: [12, "fSAMPLING=fDTS/16, N=8"]
      FDTS_Div32_N5: [13, "fSAMPLING=fDTS/32, N=5"]
      FDTS_Div32_N6: [14, "fSAMPLING=fDTS/32, N=6"]
      FDTS_Div32_N8: [15, "fSAMPLING=fDTS/32, N=8"]
    MOE:
      Disabled: [0, "In response to a break 2 event OC and OCN outputs are disabled - In response to a break event or if MOE is written to 0 OC and OCN outputs are disabled or forced to idle state depending on the OSSI bit"]
      Enabled: [1, "OC and OCN outputs are enabled if their respective enable bits are set (CCxE, CCxNE in TIMx_CCER register)"]
    AOE:
      Disabled: [0, "MOE can be set only by software"]
      Enabled: [1, "MOE can be set by software or automatically at the next update event (if none of the break inputs BRK and BRK2 is active)"]
    BKP:
      ActiveLow: [0, "Break input BRK is active low"]
      ActiveHigh: [1, "Break input BRK is active high"]
    BKE:
      Disabled: [0, "Break function disabled"]
      Enabled: [1, "Break function enabled"]
    OSSR:
      Disabled: [0, "OC/OCN outputs are disabled when inactive"]
      Enabled: [1, "OC/OCN outputs are enabled with their inactive level as soon as CCxE=1 or CCxNE=1"]
    OSSI:
      Disabled: [0, "OC/OCN outputs are disabled when inactive"]
      Enabled: [1, "OC/OCN outputs are first forced with their inactive level then forced to their idle level after the deadtime"]
    LOCK:
      "Off": [0, "No write protection"]
      Level1: [1, "Level 1 write protection"]
      Level2: [2, "Level 2 write protection"]
      Level3: [3, "Level 3 write protection"]
    DTG: [0, 0xFF]
  AF1:
    BKINP:
      NotInverted: [0, 'Input polarity not inverted']
      Inverted: [1, 'Input polarity inverted']
    BKINE:
      Disabled: [0, "BKIN input disabled"]
      Enabled: [1, "BKIN input enabled"]
TIM8:
  AF2:
    BK2DF1BK3E:
      Disabled: [0, "dfsdm1_break[3] input disabled"]
      Enabled: [1, "dfsdm1_break[3] input enabled"]

TIM*:
  CR1:
    OPM:
      NotStopped: [0, "Not stopped at update event"]
      Stopped: [1, "Counter stops counting at next update event"]
    UIFREMAP:
      Disabled: [0, "No remapping. UIF status bit is not copied to TIMx_CNT register bit 31"]
      Enabled: [1, "Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31"]
    ARPE:
      Disabled: [0, "TIMx_APRR register is not buffered"]
      Enabled: [1, "TIMx_APRR register is buffered"]
    URS:
      AnyEvent: [0, "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
      CounterOnly: [1, "Only counter overflow/underflow generates an update interrupt or DMA request"]
    UDIS:
      Enabled: [0, "Update event enabled"]
      Disabled: [1, "Update event disabled"]
    CEN:
      Disabled: [0, "Counter disabled"]
      Enabled: [1, "Counter enabled"]
  DIER:
    UIE:
      Disabled: [0, "Update interrupt disabled"]
      Enabled: [1, "Update interrupt enabled"]
  SR:
    UIF:
      Clear: [0, "No update occurred"]
      UpdatePending: [1, "Update interrupt pending."]
  EGR:
    UG:
      Update: [1, "Re-initializes the timer counter and generates an update of the registers."]
  PSC:
    PSC: [0, 65535]

TIM[1-58],TIM1[2-5]:
  EGR:
    "CC?G":
      _write:
        Trigger: [1, "If CCx is an output: CCxIF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CCx is an input: The current value of the counter is captured in TIMx_CCR1 register."]
  CCMR?_Input:
    IC?F:
      NoFilter: [0, "No filter, sampling is done at fDTS"]
      FCK_INT_N2: [1, "fSAMPLING=fCK_INT, N=2"]
      FCK_INT_N4: [2, "fSAMPLING=fCK_INT, N=4"]
      FCK_INT_N8: [3, "fSAMPLING=fCK_INT, N=8"]
      FDTS_Div2_N6: [4, "fSAMPLING=fDTS/2, N=6"]
      FDTS_Div2_N8: [5, "fSAMPLING=fDTS/2, N=8"]
      FDTS_Div4_N6: [6, "fSAMPLING=fDTS/4, N=6"]
      FDTS_Div4_N8: [7, "fSAMPLING=fDTS/4, N=8"]
      FDTS_Div8_N6: [8, "fSAMPLING=fDTS/8, N=6"]
      FDTS_Div8_N8: [9, "fSAMPLING=fDTS/8, N=8"]
      FDTS_Div16_N5: [10, "fSAMPLING=fDTS/16, N=5"]
      FDTS_Div16_N6: [11, "fSAMPLING=fDTS/16, N=6"]
      FDTS_Div16_N8: [12, "fSAMPLING=fDTS/16, N=8"]
      FDTS_Div32_N5: [13, "fSAMPLING=fDTS/32, N=5"]
      FDTS_Div32_N6: [14, "fSAMPLING=fDTS/32, N=6"]
      FDTS_Div32_N8: [15, "fSAMPLING=fDTS/32, N=8"]
    IC?PSC:
      NoPrescaler: [0b00, "No prescaler, capture is done each time an edge is detected on the capture input"]
      Every2Events: [0b01, "Capture is done once every 2 events"]
      Every4Events: [0b10, "Capture is done once every 4 events"]
      Every8Events: [0b11, "Capture is done once every 8 events"]
  CCMR1_Input:
    CC?S:
      TI1: [1, "Channel is configured as input, ICx is mapped on TI1"]
      TI2: [2, "Channel is configured as input, ICx is mapped on TI2"]
      TRC: [3, "Channel is configured as input, ICx is mapped on TRC"]
  CCMR?_Output:
    OC?PE:
      Disabled: [0, "Preload register on CCR1 disabled. New values written to CCR1 are taken into account immediately"]
      Enabled: [1, "Preload register on CCR1 enabled. Preload value is loaded into active register on each update event"]
    OC?FE:
      Disabled: [0, "Fast output disabled"]
      Enabled: [1, "Fast output enabled"]
    OC?M:
      Frozen: [0, "The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive"]
      ActiveOnMatch: [1, "Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1"]
      InactiveOnMatch: [2, "Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved"]
      Toggle: [3, "OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved"]
      ForceInactive: [4, "OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF"]
      ForceActive: [5, "OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF"]
      PwmMode1: [6, "In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active / AsymmetricPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down"]
      PwmMode2: [7, "Inversely to PwmMode1 / AsymmetricPwmMode2: Inversely to AsymmetricPwmMode1"]
    OC?M_3:
      Normal: [0, "Normal output compare mode (modes 0-7)"]
      Extended: [1, "Extended output compare mode (modes 7-15)"]
  CCMR[12]_Output:
    CC?S:
      Output: [0, "Channel is configured as output"]

TIM[1-58],TIM1[25]:
  CR2:
    TI1S:
      Normal: [0, "The TIMx_CH1 pin is connected to TI1 input"]
      XOR: [1, "The TIMx_CH1, CH2, CH3 pins are connected to TI1 input"]
  SMCR:
    MSM:
      NoSync: [0, "No action"]
      Sync: [1, "The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event."]
    TS:
      ITR0: [0, "Internal Trigger 0 (ITR0)"]
      ITR1: [1, "Internal Trigger 1 (ITR1)"]
      ITR2: [2, "Internal Trigger 2 (ITR2)"]
      TI1F_ED: [4, "TI1 Edge Detector (TI1F_ED)"]
      TI1FP1: [5, "Filtered Timer Input 1 (TI1FP1)"]
      TI2FP2: [6, "Filtered Timer Input 2 (TI2FP2)"]
      ETRF: [7, "External Trigger input (ETRF)"]
    SMS:
      Disabled: [0, "Slave mode disabled - if CEN = ‘1 then the prescaler is clocked directly by the internal clock."]
      Encoder_Mode_1: [1, "Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level."]
      Encoder_Mode_2: [2, "Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level."]
      Encoder_Mode_3: [3, "Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input."]
      Reset_Mode: [4, "Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers."]
      Gated_Mode: [5, "Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled."]
      Trigger_Mode: [6, "Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled."]
      Ext_Clock_Mode: [7, "External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter."]
    SMS_3:
      Disabled: [0, "Slave mode disabled (see SMS[0:2])"]
      CombinedResetTrigger: [1, "SMS[0:2] must be 0b000 (DisabledOrCombined). Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter"]
    TS_4_3: [0, 3]
  DIER:
    TIE:
      Disabled: [0, "Trigger interrupt disabled"]
      Enabled: [1, "Trigger interrupt enabled"]
  SR:
    TIF:
      _read:
        NoTrigger: [0, "No trigger event occurred"]
        Trigger: [1, "Trigger interrupt pending"]
      _write:
        Clear: [0, "Clear flag"]
  EGR:
    TG:
      _write:
        Trigger: [1, "The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled."]

TIM[1-8],TIM1[25]:
  CR2:
    MMS:
      Reset: [0, "The UG bit from the TIMx_EGR register is used as trigger output"]
      Enable: [1, "The counter enable signal, CNT_EN, is used as trigger output"]
      Update: [2, "The update event is selected as trigger output"]
      ComparePulse: [3, "The trigger output send a positive pulse when the CC1IF flag it to be set, as soon as a capture or a compare match occurred"]
      CompareOC1: [4, "OC1REF signal is used as trigger output"]
      CompareOC2: [5, "OC2REF signal is used as trigger output"]
      CompareOC3: [6, "OC3REF signal is used as trigger output"]
      CompareOC4: [7, "OC4REF signal is used as trigger output"]

TIM[1346-8],TIM1[2-7]:
  CNT:
    _modify:
      UIFCPY:
        description: >
          Update interrupt flag Copy
          This bit is a read-only copy of the UIF bit of the TIMx_ISR register
    UIFCPY:
      _read:
        NoUpdateOccured: [0, "No update occurred"]
        UpdateOccured: [1, "Update interrupt pending"]
    CNT: [0, 65535]
  ARR:
    ARR: [0, 65535]

TIM[1348],TIM1[2-7]:
  CCR?:
    CCR?: [0, 65535]

TIM[25]:
  CNT:
    CNT: [0, 4294967295]
  ARR:
    ARR: [0, 4294967295]
  CCR?:
    CCR?: [0, 4294967295]

TIM[1-58],TIM1[5-7]:
  CR2:
    CCDS:
      OnCompare: [0, "CCx DMA request sent when CCx event occurs"]
      OnUpdate: [1, "CCx DMA request sent when update event occurs"]
  DIER:
    "CC?DE":
      Disabled: [0, "CCx DMA request disabled"]
      Enabled: [1, "CCx DMA request enabled"]
  DCR:
    DBL: [0, 18]
    DBA: [0, 31]
  DMAR:
    DMAB: [0, 0xFFFF]

TIM[1-8],TIM1[5-7]:
  DIER:
    UDE:
      Disabled: [0, "Update DMA request disabled"]
      Enabled: [1, "Update DMA request enabled"]

TIM[1-58],TIM1[2-7]:
  CR1:
    CKD:
      Div1: [0, "t_DTS = t_CK_INT"]
      Div2: [1, "t_DTS = 2 × t_CK_INT"]
      Div4: [2, "t_DTS = 4 × t_CK_INT"]
  TISEL:
    TI?SEL:
      Selected: [0, "CHx input selected"]
  DIER:
    "CC?IE":
      Disabled: [0, "CCx interrupt disabled"]
      Enabled: [1, "CCx interrupt enabled"]
  SR:
    "CC?OF":
      _read:
        Overcapture: [1, "The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set"]
      _write:
        Clear: [0, "Clear flag"]
    "CC?IF":
      _read:
        Match: [1, "If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register."]
      _write:
        Clear: [0, "Clear flag"]
  CCER:
    "CC?NP":
      ActiveHigh: [0, "OCxN active high"]
      ActiveLow: [1, "OCxN active low"]
    "CC?P":
      RisingEdge: [0, "Noninverted/rising edge"]
      FallingEdge: [1, "Inverted/falling edge"]
    "CC?E":
      Disabled: [0, "Capture disabled"]
      Enabled: [1, "Capture enabled"]

TIM[18],TIM15:
  EGR:
    BG:
      _write:
        Trigger: [1, "A break event is generated. MOE bit is cleared and BIF flag is set. Related interrupt or DMA transfer can occur if enabled"]
    COMG:
      _write:
        Trigger: [1, "When CCPC bit is set, it allows CCxE, CCxNE and OCxM bits to be updated"]

TIM[1-58],TIM15:
  DIER:
    TDE:
      Disabled: [0, "Trigger DMA request disabled"]
      Enabled: [1, "Trigger DMA request enabled"]
  CCMR?_Output:
    OC?CE:
      Disabled: [0, "OCxRef is not affected by the ocref_clr_int signal"]
      Enabled: [1, "OCxRef is cleared as soon as a High level is detected on ocref_clr_int signal"]