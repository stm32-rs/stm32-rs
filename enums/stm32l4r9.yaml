---
PWR:
  PWR_CR1:
    LPMS:
      B_0x0: [0, Stop 0 mode]
      B_0x1: [1, Stop 1 mode]
      B_0x2: [2, Stop 2 mode]
      B_0x3: [3, Standby mode]
    RRSTP:
      B_0x0: [0, SRAM3 is powered off in Stop 2 mode (SRAM3 content is lost)]
      B_0x1: [1, SRAM3 is powered in Stop 2 mode (RAM3 content is kept).]
    DBP:
      B_0x0: [0, Access to RTC and Backup registers disabled]
      B_0x1: [1, Access to RTC and Backup registers enabled]
    VOS:
      B_0x0: [0, Cannot be written (forbidden by hardware)]
      B_0x1: [1, Range 1]
      B_0x2: [2, Range 2]
      B_0x3: [3, Cannot be written (forbidden by hardware)]
  PWR_CR2:
    PVDE:
      B_0x0: [0, Power voltage detector disable.]
      B_0x1: [1, Power voltage detector enable.]
    PLS:
      B_0x0: [0, V<sub>PVD0</sub> around 2.0 V]
      B_0x1: [1, V<sub>PVD1</sub> around 2.2 V]
      B_0x2: [2, V<sub>PVD2</sub> around 2.4 V]
      B_0x3: [3, V<sub>PVD3</sub> around 2.5 V]
      B_0x4: [4, V<sub>PVD4</sub> around 2.6 V]
      B_0x5: [5, V<sub>PVD5</sub> around 2.8 V]
      B_0x6: [6, V<sub>PVD6</sub> around 2.9 V]
      B_0x7: [7, External input analog voltage PVD_IN (compared internally to VREFINT)]
    PVME1:
      B_0x0: [0, PVM1 (V<sub>DDUSB</sub> monitoring vs. 1.2V threshold) disable.]
      B_0x1: [1, PVM1 (V<sub>DDUSB</sub> monitoring vs. 1.2V threshold) enable.]
    PVME2:
      B_0x0: [0, PVM2 (V<sub>DDIO2</sub> monitoring vs. 0.9V threshold) disable.]
      B_0x1: [1, PVM2 (V<sub>DDIO2</sub> monitoring vs. 0.9V threshold) enable.]
    PVME3:
      B_0x0: [0, PVM3 (V<sub>DDA</sub> monitoring vs. 1.62V threshold) disable.]
      B_0x1: [1, PVM3 (V<sub>DDA</sub> monitoring vs. 1.62V threshold) enable.]
    PVME4:
      B_0x0: [0, PVM4 (V<sub>DDA</sub> monitoring vs. 2.2V threshold) disable.]
      B_0x1: [1, PVM4 (V<sub>DDA</sub> monitoring vs. 2.2V threshold) enable.]
    IOSV:
      B_0x0: [0, V<sub>DDIO2</sub> is not present. Logical and electrical isolation is applied to ignore this supply.]
      B_0x1: [1, V<sub>DDIO2</sub> is valid.]
    USV:
      B_0x0: [0, V<sub>DDUSB</sub> is not present. Logical and electrical isolation is applied to ignore this supply.]
      B_0x1: [1, V<sub>DDUSB</sub> is valid.]
  PWR_CR3:
    RRS:
      B_0x0: [0, SRAM2 is powered off in Standby mode (SRAM2 content is lost).]
      B_0x1: [1, Full SRAM2 is powered by the low-power regulator in Standby mode (SRAM2 full content is kept).]
      B_0x2: [2, Only 4 Kbytes of SRAM2 is powered by the low-power regulator in Standby mode (4 Kbytes of SRAM2 content is kept)]
    DSIPDEN:
      B_0x1: [1, Pull-Down is enabled on DSI pins.]
      B_0x0: [0, Pull-Down is disabled on DSI pins.]
    EIWUL:
      B_0x0: [0, Internal wakeup line disable.]
      B_0x1: [1, Internal wakeup line enable.]
  PWR_CR4:
    WP1:
      B_0x0: [0, Detection on high level (rising edge)]
      B_0x1: [1, Detection on low level (falling edge)]
    WP2:
      B_0x0: [0, Detection on high level (rising edge)]
      B_0x1: [1, Detection on low level (falling edge)]
    WP3:
      B_0x0: [0, Detection on high level (rising edge)]
      B_0x1: [1, Detection on low level (falling edge)]
    WP4:
      B_0x0: [0, Detection on high level (rising edge)]
      B_0x1: [1, Detection on low level (falling edge)]
    WP5:
      B_0x0: [0, Detection on high level (rising edge)]
      B_0x1: [1, Detection on low level (falling edge)]
    VBE:
      B_0x0: [0, V<sub>BAT</sub> battery charging disable]
      B_0x1: [1, V<sub>BAT</sub> battery charging enable]
    VBRS:
      B_0x0: [0, Charge V<sub>BAT</sub> through a 5 kOhms resistor]
      B_0x1: [1, Charge V<sub>BAT</sub> through a 1.5 kOhms resistor]
    EXT_SMPS_ON:
      B_0x0: [0, the external SMPS switch is open.]
      B_0x1: [1, "the external SMPS switch is closed, internal regulator output is set to 0.95 V."]
  PWR_SR1:
    SBF:
      B_0x0: [0, The device did not enter the Standby mode]
      B_0x1: [1, The device entered the Standby mode]
    EXT_SMPS_RDY:
      B_0x0: [0, "Internal regulator not ready in Range 2, the external SMPS cannot be connected"]
      B_0x1: [1, "Internal regulator ready in Range 2, the external SMPS can be connected"]
  PWR_SR2:
    REGLPS:
      B_0x0: [0, The low-power regulator is not ready]
      B_0x1: [1, The low-power regulator is ready]
    REGLPF:
      B_0x0: [0, The regulator is ready in main mode (MR)]
      B_0x1: [1, The regulator is in low-power mode (LPR)]
    VOSF:
      B_0x0: [0, The regulator is ready in the selected voltage range]
      B_0x1: [1, The regulator output voltage is changing to the required voltage level]
    PVDO:
      B_0x0: [0, V<sub>DD</sub> is above the selected PVD threshold]
      B_0x1: [1, V<sub>DD</sub> is below the selected PVD threshold]
    PVMO1:
      B_0x0: [0, V<sub>DDUSB</sub> voltage is above PVM1 threshold (around 1.2 V).]
      B_0x1: [1, V<sub>DDUSB</sub> voltage is below PVM1 threshold (around 1.2 V).]
    PVMO2:
      B_0x0: [0, V<sub>DDIO2</sub> voltage is above PVM2 threshold (around 0.9 V).]
      B_0x1: [1, V<sub>DDIO2</sub> voltage is below PVM2 threshold (around 0.9 V).]
    PVMO3:
      B_0x0: [0, V<sub>DDA</sub> voltage is above PVM3 threshold (around 1.62 V).]
      B_0x1: [1, V<sub>DDA</sub> voltage is below PVM3 threshold (around 1.62 V).]
    PVMO4:
      B_0x0: [0, V<sub>DDA</sub> voltage is above PVM4 threshold (around 2.2 V).]
      B_0x1: [1, V<sub>DDA</sub> voltage is below PVM4 threshold (around 2.2 V).]
  PWR_CR5:
    R1MODE:
      B_0x0: [0, Main regulator in Range 1 boost mode.]
      B_0x1: [1, Main regulator in Range 1 normal mode.]
TIM1:
  TIM1_CR1:
    CEN:
      B_0x0: [0, Counter disabled]
      B_0x1: [1, Counter enabled]
    UDIS:
      B_0x0: [0, "UEV enabled. The Update (UEV) event is generated by one of the following events:"]
      B_0x1: [1, "UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller."]
    URS:
      B_0x0: [0, "Any of the following events generate an update interrupt or DMA request if enabled. These events can be:"]
      B_0x1: [1, Only counter overflow/underflow generates an update interrupt or DMA request if enabled.]
    OPM:
      B_0x0: [0, Counter is not stopped at update event]
      B_0x1: [1, Counter stops counting at the next update event (clearing the bit CEN)]
    DIR:
      B_0x0: [0, Counter used as upcounter]
      B_0x1: [1, Counter used as downcounter]
    CMS:
      B_0x0: [0, Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).]
      B_0x1: [1, Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting down.]
      B_0x2: [2, Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting up.]
      B_0x3: [3, Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set both when the counter is counting up or down.]
    ARPE:
      B_0x0: [0, TIMx_ARR register is not buffered]
      B_0x1: [1, TIMx_ARR register is buffered]
    CKD:
      B_0x0: [0, t<sub>DTS</sub>=t<sub>CK_INT</sub>]
      B_0x1: [1, t<sub>DTS</sub>=2*t<sub>CK_INT</sub>]
      B_0x2: [2, t<sub>DTS</sub>=4*t<sub>CK_INT</sub>]
      B_0x3: [3, "Reserved, do not program this value"]
    UIFREMAP:
      B_0x0: [0, No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.]
      B_0x1: [1, Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.]
  TIM1_CR2:
    CCPC:
      B_0x0: [0, "CCxE, CCxNE and OCxM bits are not preloaded"]
      B_0x1: [1, "CCxE, CCxNE and OCxM bits are preloaded, after having been written, they are updated only when a commutation event (COM) occurs (COMG bit set or rising edge detected on TRGI, depending on the CCUS bit)."]
    CCUS:
      B_0x0: [0, "When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit only"]
      B_0x1: [1, "When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit or when an rising edge occurs on TRGI"]
    CCDS:
      B_0x0: [0, CCx DMA request sent when CCx event occurs]
      B_0x1: [1, CCx DMA requests sent when update event occurs]
    MMS:
      B_0x0: [0, Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.]
      B_0x1: [1, "Enable - the Counter Enable signal CNT_EN is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enable. The Counter Enable signal is generated by a logic AND between CEN control bit and the trigger input when configured in gated mode. When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR register)."]
      B_0x2: [2, Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.]
      B_0x3: [3, "Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO)."]
      B_0x4: [4, Compare - OC1REFC signal is used as trigger output (TRGO)]
      B_0x5: [5, Compare - OC2REFC signal is used as trigger output (TRGO)]
      B_0x6: [6, Compare - OC3REFC signal is used as trigger output (TRGO)]
      B_0x7: [7, Compare - OC4REFC signal is used as trigger output (TRGO)]
    TI1S:
      B_0x0: [0, The TIMx_CH1 pin is connected to TI1 input]
      B_0x1: [1, "The TIMx_CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination)"]
    OIS1:
      B_0x0: [0, OC1=0 (after a dead-time if OC1N is implemented) when MOE=0]
      B_0x1: [1, OC1=1 (after a dead-time if OC1N is implemented) when MOE=0]
    OIS1N:
      B_0x0: [0, OC1N=0 after a dead-time when MOE=0]
      B_0x1: [1, OC1N=1 after a dead-time when MOE=0]
    MMS2:
      B_0x0: [0, "Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO2). If the reset is generated by the trigger input (slave mode controller configured in reset mode), the signal on TRGO2 is delayed compared to the actual reset."]
      B_0x1: [1, "Enable - the Counter Enable signal CNT_EN is used as trigger output (TRGO2). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic AND between the CEN control bit and the trigger input when configured in Gated mode. When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO2, except if the Master/Slave mode is selected (see the MSM bit description in TIMx_SMCR register)."]
      B_0x2: [2, "Update - the update event is selected as trigger output (TRGO2). For instance, a master timer can then be used as a prescaler for a slave timer."]
      B_0x3: [3, "Compare pulse - the trigger output sends a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or compare match occurs (TRGO2)."]
      B_0x4: [4, Compare - OC1REFC signal is used as trigger output (TRGO2)]
      B_0x5: [5, Compare - OC2REFC signal is used as trigger output (TRGO2)]
      B_0x6: [6, Compare - OC3REFC signal is used as trigger output (TRGO2)]
      B_0x7: [7, Compare - OC4REFC signal is used as trigger output (TRGO2)]
      B_0x8: [8, Compare - OC5REFC signal is used as trigger output (TRGO2)]
      B_0x9: [9, Compare - OC6REFC signal is used as trigger output (TRGO2)]
      B_0xA: [10, Compare Pulse - OC4REFC rising or falling edges generate pulses on TRGO2]
      B_0xB: [11, Compare Pulse - OC6REFC rising or falling edges generate pulses on TRGO2]
      B_0xC: [12, Compare Pulse - OC4REFC or OC6REFC rising edges generate pulses on TRGO2]
      B_0xD: [13, Compare Pulse - OC4REFC rising or OC6REFC falling edges generate pulses on TRGO2]
      B_0xE: [14, Compare Pulse - OC5REFC or OC6REFC rising edges generate pulses on TRGO2]
      B_0xF: [15, Compare Pulse - OC5REFC rising or OC6REFC falling edges generate pulses on TRGO2]
  TIM1_SMCR:
    SMS:
      B_0x0: [0, Slave mode disabled - if CEN =  1  then the prescaler is clocked directly by the internal clock.]
      B_0x1: [1, Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.]
      B_0x2: [2, Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.]
      B_0x3: [3, Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.]
      B_0x4: [4, Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.]
      B_0x5: [5, Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.]
      B_0x6: [6, Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.]
      B_0x7: [7, External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.]
    TS:
      B_0x0: [0, Internal Trigger 0 (ITR0)]
      B_0x1: [1, Internal Trigger 1 (ITR1)]
      B_0x2: [2, Internal Trigger 2 (ITR2)]
      B_0x3: [3, Internal Trigger 3 (ITR3)]
      B_0x4: [4, TI1 Edge Detector (TI1F_ED)]
      B_0x5: [5, Filtered Timer Input 1 (TI1FP1)]
      B_0x6: [6, Filtered Timer Input 2 (TI2FP2)]
      B_0x7: [7, External Trigger input (ETRF)]
    MSM:
      B_0x0: [0, No action]
      B_0x1: [1, The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.]
    ETF:
      B_0x0: [0, "No filter, sampling is done at f<sub>DTS</sub>"]
      B_0x1: [1, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=2"]
      B_0x2: [2, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=4"]
      B_0x3: [3, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=8"]
      B_0x4: [4, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=6"]
      B_0x5: [5, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=8"]
      B_0x6: [6, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=6"]
      B_0x7: [7, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=8"]
      B_0x8: [8, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=6"]
      B_0x9: [9, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=8"]
      B_0xA: [10, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=5"]
      B_0xB: [11, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=6"]
      B_0xC: [12, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=8"]
      B_0xD: [13, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=5"]
      B_0xE: [14, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=6"]
      B_0xF: [15, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=8"]
    ETPS:
      B_0x0: [0, Prescaler OFF]
      B_0x1: [1, ETRP frequency divided by 2]
      B_0x2: [2, ETRP frequency divided by 4]
      B_0x3: [3, ETRP frequency divided by 8]
    ECE:
      B_0x0: [0, External clock mode 2 disabled]
      B_0x1: [1, External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.]
    ETP:
      B_0x0: [0, "ETR is non-inverted, active at high level or rising edge."]
      B_0x1: [1, "ETR is inverted, active at low level or falling edge."]
  TIM1_DIER:
    UIE:
      B_0x0: [0, Update interrupt disabled]
      B_0x1: [1, Update interrupt enabled]
    CC1IE:
      B_0x0: [0, CC1 interrupt disabled]
      B_0x1: [1, CC1 interrupt enabled]
    CC2IE:
      B_0x0: [0, CC2 interrupt disabled]
      B_0x1: [1, CC2 interrupt enabled]
    CC3IE:
      B_0x0: [0, CC3 interrupt disabled]
      B_0x1: [1, CC3 interrupt enabled]
    CC4IE:
      B_0x0: [0, CC4 interrupt disabled]
      B_0x1: [1, CC4 interrupt enabled]
    COMIE:
      B_0x0: [0, COM interrupt disabled]
      B_0x1: [1, COM interrupt enabled]
    TIE:
      B_0x0: [0, Trigger interrupt disabled]
      B_0x1: [1, Trigger interrupt enabled]
    BIE:
      B_0x0: [0, Break interrupt disabled]
      B_0x1: [1, Break interrupt enabled]
    UDE:
      B_0x0: [0, Update DMA request disabled]
      B_0x1: [1, Update DMA request enabled]
    CC1DE:
      B_0x0: [0, CC1 DMA request disabled]
      B_0x1: [1, CC1 DMA request enabled]
    CC2DE:
      B_0x0: [0, CC2 DMA request disabled]
      B_0x1: [1, CC2 DMA request enabled]
    CC3DE:
      B_0x0: [0, CC3 DMA request disabled]
      B_0x1: [1, CC3 DMA request enabled]
    CC4DE:
      B_0x0: [0, CC4 DMA request disabled]
      B_0x1: [1, CC4 DMA request enabled]
    COMDE:
      B_0x0: [0, COM DMA request disabled]
      B_0x1: [1, COM DMA request enabled]
    TDE:
      B_0x0: [0, Trigger DMA request disabled]
      B_0x1: [1, Trigger DMA request enabled]
  TIM1_SR:
    UIF:
      B_0x0: [0, No update occurred.]
      B_0x1: [1, "Update interrupt pending. This bit is set by hardware when the registers are updated:"]
    CC1IF:
      B_0x0: [0, No compare match / No input capture occurred]
      B_0x1: [1, A compare match or an input capture occurred.]
    COMIF:
      B_0x0: [0, No COM event occurred.]
      B_0x1: [1, COM interrupt pending.]
    TIF:
      B_0x0: [0, No trigger event occurred.]
      B_0x1: [1, Trigger interrupt pending.]
    BIF:
      B_0x0: [0, No break event occurred.]
      B_0x1: [1, An active level has been detected on the break input. An interrupt is generated if BIE=1 in the TIMx_DIER register.]
    B2IF:
      B_0x0: [0, No break event occurred.]
      B_0x1: [1, An active level has been detected on the break 2 input. An interrupt is generated if BIE=1 in the TIMx_DIER register.]
    CC1OF:
      B_0x0: [0, No overcapture has been detected.]
      B_0x1: [1, The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set]
    SBIF:
      B_0x0: [0, No break event occurred.]
      B_0x1: [1, An active level has been detected on the system break input. An interrupt is generated if BIE=1 in the TIMx_DIER register.]
  TIM1_EGR:
    UG:
      B_0x0: [0, No action]
      B_0x1: [1, "Reinitialize the counter and generates an update of the registers. The prescaler internal counter is also cleared (the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (TIMx_ARR) if DIR=1 (downcounting)."]
    CC1G:
      B_0x0: [0, No action]
      B_0x1: [1, "A capture/compare event is generated on channel 1:"]
    COMG:
      B_0x0: [0, No action]
      B_0x1: [1, "When CCPC bit is set, it allows CCxE, CCxNE and OCxM bits to be updated."]
    TG:
      B_0x0: [0, No action]
      B_0x1: [1, The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.]
    BG:
      B_0x0: [0, No action]
      B_0x1: [1, A break event is generated. MOE bit is cleared and BIF flag is set. Related interrupt or DMA transfer can occur if enabled.]
    B2G:
      B_0x0: [0, No action]
      B_0x1: [1, A break 2 event is generated. MOE bit is cleared and B2IF flag is set. Related interrupt can occur if enabled.]
  TIM1_CCMR1:
    CC1S:
      B_0x0: [0, CC1 channel is configured as output]
      B_0x1: [1, "CC1 channel is configured as input, IC1 is mapped on TI1"]
      B_0x2: [2, "CC1 channel is configured as input, IC1 is mapped on TI2"]
      B_0x3: [3, "CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
    IC1PSC:
      B_0x0: [0, "no prescaler, capture is done each time an edge is detected on the capture input"]
      B_0x1: [1, capture is done once every 2 events]
      B_0x2: [2, capture is done once every 4 events]
      B_0x3: [3, capture is done once every 8 events]
    IC1F:
      B_0x0: [0, "No filter, sampling is done at f<sub>DTS</sub>"]
      B_0x1: [1, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=2"]
      B_0x2: [2, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=4"]
      B_0x3: [3, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=8"]
      B_0x4: [4, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=6"]
      B_0x5: [5, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=8"]
      B_0x6: [6, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=6"]
      B_0x7: [7, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=8"]
      B_0x8: [8, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=6"]
      B_0x9: [9, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=8"]
      B_0xA: [10, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=5"]
      B_0xB: [11, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=6"]
      B_0xC: [12, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=8"]
      B_0xD: [13, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=5"]
      B_0xE: [14, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=6"]
      B_0xF: [15, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=8"]
    CC2S:
      B_0x0: [0, CC2 channel is configured as output]
      B_0x1: [1, "CC2 channel is configured as input, IC2 is mapped on TI2"]
      B_0x2: [2, "CC2 channel is configured as input, IC2 is mapped on TI1"]
      B_0x3: [3, "CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
  TIM1_CCMR1_ALTERNATE1:
    CC1S:
      B_0x0: [0, CC1 channel is configured as output]
      B_0x1: [1, "CC1 channel is configured as input, IC1 is mapped on TI1"]
      B_0x2: [2, "CC1 channel is configured as input, IC1 is mapped on TI2"]
      B_0x3: [3, "CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
    OC1FE:
      B_0x0: [0, CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.]
      B_0x1: [1, "An active edge on the trigger input acts like a compare match on CC1 output. Then, OC is set to the compare level independently from the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OCFE acts only if the channel is configured in PWM1 or PWM2 mode."]
    OC1PE:
      B_0x0: [0, "Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately."]
      B_0x1: [1, Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.]
    OC1M:
      B_0x0: [0, "Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.This mode can be used when the timer serves as a software timebase. When the frozen mode is enabled during timer operation, the output keeps the state (active or inactive) it had before entering the frozen state."]
      B_0x1: [1, Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).]
      B_0x2: [2, Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).]
      B_0x3: [3, Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.]
      B_0x4: [4, Force inactive level - OC1REF is forced low.]
      B_0x5: [5, Force active level - OC1REF is forced high.]
      B_0x6: [6, "PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT<TIMx_CCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF= 0 ) as long as TIMx_CNT>TIMx_CCR1 else active (OC1REF= 1 )."]
      B_0x7: [7, "PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT<TIMx_CCR1 else active. In downcounting, channel 1 is active as long as TIMx_CNT>TIMx_CCR1 else inactive."]
    OC1CE:
      B_0x0: [0, OC1Ref is not affected by the ETRF input]
      B_0x1: [1, OC1Ref is cleared as soon as a High level is detected on ETRF input]
    CC2S:
      B_0x0: [0, CC2 channel is configured as output]
      B_0x1: [1, "CC2 channel is configured as input, IC2 is mapped on TI2"]
      B_0x2: [2, "CC2 channel is configured as input, IC2 is mapped on TI1"]
      B_0x3: [3, "CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through the TS bit (TIMx_SMCR register)"]
  TIM1_CCMR2:
    CC3S:
      B_0x0: [0, CC3 channel is configured as output]
      B_0x1: [1, "CC3 channel is configured as input, IC3 is mapped on TI3"]
      B_0x2: [2, "CC3 channel is configured as input, IC3 is mapped on TI4"]
      B_0x3: [3, "CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
    CC4S:
      B_0x0: [0, CC4 channel is configured as output]
      B_0x1: [1, "CC4 channel is configured as input, IC4 is mapped on TI4"]
      B_0x2: [2, "CC4 channel is configured as input, IC4 is mapped on TI3"]
      B_0x3: [3, "CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
  TIM1_CCMR2_ALTERNATE:
    CC3S:
      B_0x0: [0, CC3 channel is configured as output]
      B_0x1: [1, "CC3 channel is configured as input, IC3 is mapped on TI3"]
      B_0x2: [2, "CC3 channel is configured as input, IC3 is mapped on TI4"]
      B_0x3: [3, "CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
    CC4S:
      B_0x0: [0, CC4 channel is configured as output]
      B_0x1: [1, "CC4 channel is configured as input, IC4 is mapped on TI4"]
      B_0x2: [2, "CC4 channel is configured as input, IC4 is mapped on TI3"]
      B_0x3: [3, "CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
  TIM1_CCER:
    CC1E:
      B_0x0: [0, Capture mode disabled / OC1 is not active (see below)]
      B_0x1: [1, Capture mode enabled / OC1 signal is output on the corresponding output pin]
    CC1P:
      B_0x0: [0, "OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)"]
      B_0x1: [1, "OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)"]
    CC1NE:
      B_0x0: [0, "Off - OC1N is not active. OC1N level is then function of MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits."]
      B_0x1: [1, "On - OC1N signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits."]
    CC1NP:
      B_0x0: [0, OC1N active high.]
      B_0x1: [1, OC1N active low.]
  TIM1_BDTR:
    LOCK:
      B_0x0: [0, LOCK OFF - No bit is write protected.]
      B_0x1: [1, "LOCK Level 1 = DTG bits in TIMx_BDTR register, OISx and OISxN bits in TIMx_CR2 register and BKE/BKP/AOE bits in TIMx_BDTR register can no longer be written."]
      B_0x2: [2, "LOCK Level 2 = LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in TIMx_CCER register, as long as the related channel is configured in output through the CCxS bits) as well as OSSR and OSSI bits can no longer be written."]
      B_0x3: [3, "LOCK Level 3 = LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in TIMx_CCMRx registers, as long as the related channel is configured in output through the CCxS bits) can no longer be written."]
    OSSI:
      B_0x0: [0, "When inactive, OC/OCN outputs are disabled (the timer releases the output control which is taken over by the GPIO logic and which imposes a Hi-Z state)."]
      B_0x1: [1, "When inactive, OC/OCN outputs are first forced with their inactive level then forced to their idle level after the deadtime. The timer maintains its control over the output."]
    OSSR:
      B_0x0: [0, "When inactive, OC/OCN outputs are disabled (the timer releases the output control which is taken over by the GPIO logic, which forces a Hi-Z state)."]
      B_0x1: [1, "When inactive, OC/OCN outputs are enabled with their inactive level as soon as CCxE=1 or CCxNE=1 (the output is still controlled by the timer)."]
    BKE:
      B_0x0: [0, Break function disabled]
      B_0x1: [1, Break function enabled]
    BKP:
      B_0x0: [0, Break input BRK is active low]
      B_0x1: [1, Break input BRK is active high]
    AOE:
      B_0x0: [0, MOE can be set only by software]
      B_0x1: [1, MOE can be set by software or automatically at the next update event (if none of the break inputs BRK and BRK2 is active)]
    MOE:
      B_0x0: [0, In response to a break 2 event. OC and OCN outputs are disabled]
      B_0x1: [1, "OC and OCN outputs are enabled if their respective enable bits are set (CCxE, CCxNE in TIMx_CCER register)."]
    BKF:
      B_0x0: [0, "No filter, BRK acts asynchronously"]
      B_0x1: [1, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=2"]
      B_0x2: [2, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=4"]
      B_0x3: [3, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=8"]
      B_0x4: [4, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=6"]
      B_0x5: [5, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=8"]
      B_0x6: [6, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=6"]
      B_0x7: [7, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=8"]
      B_0x8: [8, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=6"]
      B_0x9: [9, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=8"]
      B_0xA: [10, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=5"]
      B_0xB: [11, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=6"]
      B_0xC: [12, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=8"]
      B_0xD: [13, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=5"]
      B_0xE: [14, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=6"]
      B_0xF: [15, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=8"]
    BK2F:
      B_0x0: [0, "No filter, BRK2 acts asynchronously"]
      B_0x1: [1, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=2"]
      B_0x2: [2, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=4"]
      B_0x3: [3, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=8"]
      B_0x4: [4, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=6"]
      B_0x5: [5, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=8"]
      B_0x6: [6, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=6"]
      B_0x7: [7, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=8"]
      B_0x8: [8, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=6"]
      B_0x9: [9, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=8"]
      B_0xA: [10, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=5"]
      B_0xB: [11, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=6"]
      B_0xC: [12, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=8"]
      B_0xD: [13, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=5"]
      B_0xE: [14, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=6"]
      B_0xF: [15, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=8"]
    BK2E:
      B_0x0: [0, Break2 function disabled]
      B_0x1: [1, Break2 function enabled]
    BK2P:
      B_0x0: [0, Break input BRK2 is active low]
      B_0x1: [1, Break input BRK2 is active high]
  TIM1_DCR:
    DBA:
      B_0x0: [0, "TIMx_CR1,"]
      B_0x1: [1, "TIMx_CR2,"]
      B_0x2: [2, "TIMx_SMCR,"]
    DBL:
      B_0x0: [0, 1 transfer]
      B_0x1: [1, 2 transfers]
      B_0x2: [2, 3 transfers]
      B_0x11: [17, 18 transfers]
  TIM1_CCR5:
    GC5C1:
      B_0x0: [0, No effect of OC5REF on OC1REFC5]
      B_0x1: [1, OC1REFC is the logical AND of OC1REFC and OC5REF]
    GC5C2:
      B_0x0: [0, No effect of OC5REF on OC2REFC]
      B_0x1: [1, OC2REFC is the logical AND of OC2REFC and OC5REF]
    GC5C3:
      B_0x0: [0, No effect of OC5REF on OC3REFC]
      B_0x1: [1, OC3REFC is the logical AND of OC3REFC and OC5REF]
  TIM1_AF1:
    BKINE:
      B_0x0: [0, BKIN input disabled]
      B_0x1: [1, BKIN input enabled]
    BKCMP1E:
      B_0x0: [0, COMP1 input disabled]
      B_0x1: [1, COMP1 input enabled]
    BKCMP2E:
      B_0x0: [0, COMP2 input disabled]
      B_0x1: [1, COMP2 input enabled]
    BKDF1BK0E:
      B_0x0: [0, "dfsdm1_break[0] input disabled"]
      B_0x1: [1, "dfsdm1_break[0] input enabled"]
    BKINP:
      B_0x0: [0, "BKIN input polarity is not inverted (active low if BKP=0, active high if BKP=1)"]
      B_0x1: [1, "BKIN input polarity is inverted (active high if BKP=0, active low if BKP=1)"]
    BKCMP1P:
      B_0x0: [0, "COMP1 input polarity is not inverted (active low if BKP=0, active high if BKP=1)"]
      B_0x1: [1, "COMP1 input polarity is inverted (active high if BKP=0, active low if BKP=1)"]
    BKCMP2P:
      B_0x0: [0, "COMP2 input polarity is not inverted (active low if BKP=0, active high if BKP=1)"]
      B_0x1: [1, "COMP2 input polarity is inverted (active high if BKP=0, active low if BKP=1)"]
    ETRSEL:
      B_0x0: [0, ETR input is connected to I/O]
      B_0x1: [1, COMP1 output]
      B_0x2: [2, COMP2 output]
      B_0x3: [3, ADC1 AWD1]
      B_0x4: [4, ADC1 AWD2]
      B_0x5: [5, ADC1 AWD3]
      B_0x6: [6, ADC3 AWD1]
      B_0x7: [7, ADC3 AWD2]
      B_0x8: [8, ADC3 AWD3]
  TIM1_AF2:
    BK2INE:
      B_0x0: [0, BKIN2 input disabled]
      B_0x1: [1, BKIN2 input enabled]
    BK2CMP1E:
      B_0x0: [0, COMP1 input disabled]
      B_0x1: [1, COMP1 input enabled]
    BK2CMP2E:
      B_0x0: [0, COMP2 input disabled]
      B_0x1: [1, COMP2 input enabled]
    BK2DF1BK1E:
      B_0x0: [0, "dfsdm1_break[1] input disabled"]
      B_0x1: [1, "dfsdm1_break[1] input enabled"]
    BK2INP:
      B_0x0: [0, "BKIN2 input polarity is not inverted (active low if BK2P=0, active high if BK2P=1)"]
      B_0x1: [1, "BKIN2 input polarity is inverted (active high if BK2P=0, active low if BK2P=1)"]
    BK2CMP1P:
      B_0x0: [0, "COMP1 input polarity is not inverted (active low if BK2P=0, active high if BK2P=1)"]
      B_0x1: [1, "COMP1 input polarity is inverted (active high if BK2P=0, active low if BK2P=1)"]
    BK2CMP2P:
      B_0x0: [0, "COMP2 input polarity is not inverted (active low if BK2P=0, active high if BK2P=1)"]
      B_0x1: [1, "COMP2 input polarity is inverted (active high if BK2P=0, active low if BK2P=1)"]
  TIM1_TISEL:
    TI1SEL:
      B_0x0: [0, TIM1_CH1 input]
      B_0x1: [1, COMP1 output]
    TI2SEL:
      B_0x0: [0, TIM1_CH2 input]
    TI3SEL:
      B_0x0: [0, TIM1_CH3 input]
    TI4SEL:
      B_0x0: [0, TIM1_CH4 input]
TIM2:
  TIM2_CR1:
    CEN:
      B_0x0: [0, Counter disabled]
      B_0x1: [1, Counter enabled]
    UDIS:
      B_0x0: [0, "UEV enabled. The Update (UEV) event is generated by one of the following events:"]
      B_0x1: [1, "UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller."]
    URS:
      B_0x0: [0, "Any of the following events generate an update interrupt or DMA request if enabled. These events can be:"]
      B_0x1: [1, Only counter overflow/underflow generates an update interrupt or DMA request if enabled.]
    OPM:
      B_0x0: [0, Counter is not stopped at update event]
      B_0x1: [1, Counter stops counting at the next update event (clearing the bit CEN)]
    DIR:
      B_0x0: [0, Counter used as upcounter]
      B_0x1: [1, Counter used as downcounter]
    CMS:
      B_0x0: [0, Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).]
      B_0x1: [1, Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting down.]
      B_0x2: [2, Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting up.]
      B_0x3: [3, Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set both when the counter is counting up or down.]
    ARPE:
      B_0x0: [0, TIMx_ARR register is not buffered]
      B_0x1: [1, TIMx_ARR register is buffered]
    CKD:
      B_0x0: [0, t<sub>DTS</sub> = t<sub>CK_INT</sub>]
      B_0x1: [1, t<sub>DTS</sub> = 2   t<sub>CK_INT</sub>]
      B_0x2: [2, t<sub>DTS</sub> = 4   t<sub>CK_INT</sub>]
    UIFREMAP:
      B_0x0: [0, No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.]
      B_0x1: [1, Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.]
  TIM2_CR2:
    CCDS:
      B_0x0: [0, CCx DMA request sent when CCx event occurs]
      B_0x1: [1, CCx DMA requests sent when update event occurs]
    MMS:
      B_0x0: [0, Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.]
      B_0x1: [1, "Enable - the Counter enable signal, CNT_EN, is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic AND between CEN control bit and the trigger input when configured in gated mode."]
      B_0x2: [2, Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.]
      B_0x3: [3, "Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO)"]
      B_0x4: [4, Compare - OC1REFC signal is used as trigger output (TRGO)]
      B_0x5: [5, Compare - OC2REFC signal is used as trigger output (TRGO)]
      B_0x6: [6, Compare - OC3REFC signal is used as trigger output (TRGO)]
      B_0x7: [7, Compare - OC4REFC signal is used as trigger output (TRGO)]
    TI1S:
      B_0x0: [0, The TIMx_CH1 pin is connected to TI1 input]
      B_0x1: [1, "The TIMx_CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination) See also Section 24.3.25: Interfacing with Hall sensors on page 713"]
  TIM2_SMCR:
    SMS:
      B_0x0: [0, Slave mode disabled - if CEN =  1 then the prescaler is clocked directly by the internal clock.]
      B_0x1: [1, Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.]
      B_0x2: [2, Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.]
      B_0x3: [3, Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.]
      B_0x4: [4, Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.]
      B_0x5: [5, Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.]
      B_0x6: [6, Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.]
      B_0x7: [7, External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.]
    TS:
      B_0x0: [0, Internal Trigger 0 (ITR0)]
      B_0x1: [1, Internal Trigger 1 (ITR1)]
      B_0x2: [2, Internal Trigger 2 (ITR2)]
      B_0x3: [3, Internal Trigger 3 (ITR3)]
      B_0x4: [4, TI1 Edge Detector (TI1F_ED)]
      B_0x5: [5, Filtered Timer Input 1 (TI1FP1)]
      B_0x6: [6, Filtered Timer Input 2 (TI2FP2)]
      B_0x7: [7, External Trigger input (ETRF)]
    MSM:
      B_0x0: [0, No action]
      B_0x1: [1, The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.]
    ETF:
      B_0x0: [0, "No filter, sampling is done at f<sub>DTS</sub>"]
      B_0x1: [1, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=2"]
      B_0x2: [2, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=4"]
      B_0x3: [3, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=8"]
      B_0x4: [4, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=6"]
      B_0x5: [5, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=8"]
      B_0x6: [6, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=6"]
      B_0x7: [7, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=8"]
      B_0x8: [8, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=6"]
      B_0x9: [9, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=8"]
      B_0xA: [10, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=5"]
      B_0xB: [11, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=6"]
      B_0xC: [12, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=8"]
      B_0xD: [13, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=5"]
      B_0xE: [14, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=6"]
      B_0xF: [15, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=8"]
    ETPS:
      B_0x0: [0, Prescaler OFF]
      B_0x1: [1, ETRP frequency divided by 2]
      B_0x2: [2, ETRP frequency divided by 4]
      B_0x3: [3, ETRP frequency divided by 8]
    ECE:
      B_0x0: [0, External clock mode 2 disabled]
      B_0x1: [1, External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.]
    ETP:
      B_0x0: [0, "ETR is non-inverted, active at high level or rising edge"]
      B_0x1: [1, "ETR is inverted, active at low level or falling edge"]
  TIM2_DIER:
    UIE:
      B_0x0: [0, Update interrupt disabled.]
      B_0x1: [1, Update interrupt enabled.]
    CC1IE:
      B_0x0: [0, CC1 interrupt disabled.]
      B_0x1: [1, CC1 interrupt enabled.]
    CC2IE:
      B_0x0: [0, CC2 interrupt disabled.]
      B_0x1: [1, CC2 interrupt enabled.]
    CC3IE:
      B_0x0: [0, CC3 interrupt disabled.]
      B_0x1: [1, CC3 interrupt enabled.]
    CC4IE:
      B_0x0: [0, CC4 interrupt disabled.]
      B_0x1: [1, CC4 interrupt enabled.]
    TIE:
      B_0x0: [0, Trigger interrupt disabled.]
      B_0x1: [1, Trigger interrupt enabled.]
    UDE:
      B_0x0: [0, Update DMA request disabled.]
      B_0x1: [1, Update DMA request enabled.]
    CC1DE:
      B_0x0: [0, CC1 DMA request disabled.]
      B_0x1: [1, CC1 DMA request enabled.]
    CC2DE:
      B_0x0: [0, CC2 DMA request disabled.]
      B_0x1: [1, CC2 DMA request enabled.]
    CC3DE:
      B_0x0: [0, CC3 DMA request disabled.]
      B_0x1: [1, CC3 DMA request enabled.]
    CC4DE:
      B_0x0: [0, CC4 DMA request disabled.]
      B_0x1: [1, CC4 DMA request enabled.]
    TDE:
      B_0x0: [0, Trigger DMA request disabled.]
      B_0x1: [1, Trigger DMA request enabled.]
  TIM2_SR:
    UIF:
      B_0x0: [0, No update occurred]
      B_0x1: [1, "Update interrupt pending. This bit is set by hardware when the registers are updated:"]
    CC1IF:
      B_0x0: [0, No compare match / No input capture occurred]
      B_0x1: [1, A compare match or an input capture occurred]
    TIF:
      B_0x0: [0, No trigger event occurred.]
      B_0x1: [1, Trigger interrupt pending.]
    CC1OF:
      B_0x0: [0, No overcapture has been detected.]
      B_0x1: [1, The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set]
  TIM2_EGR:
    UG:
      B_0x0: [0, No action]
      B_0x1: [1, "Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (TIMx_ARR) if DIR=1 (downcounting)."]
    CC1G:
      B_0x0: [0, No action]
      B_0x1: [1, "A capture/compare event is generated on channel 1:"]
    TG:
      B_0x0: [0, No action]
      B_0x1: [1, The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.]
  TIM2_CCMR1:
    CC1S:
      B_0x0: [0, CC1 channel is configured as output]
      B_0x1: [1, "CC1 channel is configured as input, IC1 is mapped on TI1"]
      B_0x2: [2, "CC1 channel is configured as input, IC1 is mapped on TI2"]
      B_0x3: [3, "CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
    IC1PSC:
      B_0x0: [0, "no prescaler, capture is done each time an edge is detected on the capture input"]
      B_0x1: [1, capture is done once every 2 events]
      B_0x2: [2, capture is done once every 4 events]
      B_0x3: [3, capture is done once every 8 events]
    IC1F:
      B_0x0: [0, "No filter, sampling is done at f\t\t<sub>DTS</sub>"]
      B_0x1: [1, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=2"]
      B_0x2: [2, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=4"]
      B_0x3: [3, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=8"]
      B_0x4: [4, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=6"]
      B_0x5: [5, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=8"]
      B_0x6: [6, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=6"]
      B_0x7: [7, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=8"]
      B_0x8: [8, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=6"]
      B_0x9: [9, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=8"]
      B_0xA: [10, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=5"]
      B_0xB: [11, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=6"]
      B_0xC: [12, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=8"]
      B_0xD: [13, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=5"]
      B_0xE: [14, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=6"]
      B_0xF: [15, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=8"]
    CC2S:
      B_0x0: [0, CC2 channel is configured as output.]
      B_0x1: [1, "CC2 channel is configured as input, IC2 is mapped on TI2."]
      B_0x2: [2, "CC2 channel is configured as input, IC2 is mapped on TI1."]
      B_0x3: [3, "CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
  TIM2_CCMR1_ALTERNATE:
    CC1S:
      B_0x0: [0, CC1 channel is configured as output.]
      B_0x1: [1, "CC1 channel is configured as input, IC1 is mapped on TI1."]
      B_0x2: [2, "CC1 channel is configured as input, IC1 is mapped on TI2."]
      B_0x3: [3, "CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
    OC1FE:
      B_0x0: [0, CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.]
      B_0x1: [1, "An active edge on the trigger input acts like a compare match on CC1 output. Then, OC is set to the compare level independently from the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OCFE acts only if the channel is configured in PWM1 or PWM2 mode."]
    OC1PE:
      B_0x0: [0, "Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately."]
      B_0x1: [1, Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.]
    OC1M:
      B_0x0: [0, "Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs. This mode can be used when the timer serves as a software timebase. When the frozen mode is enabled during timer operation, the output keeps the state (active or inactive) it had before entering the frozen state."]
      B_0x1: [1, Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).]
      B_0x2: [2, Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).]
      B_0x3: [3, Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.]
      B_0x4: [4, Force inactive level - OC1REF is forced low.]
      B_0x5: [5, Force active level - OC1REF is forced high.]
      B_0x6: [6, "PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT<TIMx_CCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF= 0) as long as TIMx_CNT>TIMx_CCR1 else active (OC1REF=1)."]
      B_0x7: [7, "PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT<TIMx_CCR1 else active. In downcounting, channel 1 is active as long as TIMx_CNT>TIMx_CCR1 else inactive."]
    OC1CE:
      B_0x0: [0, OC1Ref is not affected by the ETRF input]
      B_0x1: [1, OC1Ref is cleared as soon as a High level is detected on ETRF input]
    CC2S:
      B_0x0: [0, CC2 channel is configured as output]
      B_0x1: [1, "CC2 channel is configured as input, IC2 is mapped on TI2"]
      B_0x2: [2, "CC2 channel is configured as input, IC2 is mapped on TI1"]
      B_0x3: [3, "CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through the TS bit (TIMx_SMCR register)"]
  TIM2_CCMR2:
    CC3S:
      B_0x0: [0, CC3 channel is configured as output]
      B_0x1: [1, "CC3 channel is configured as input, IC3 is mapped on TI3"]
      B_0x2: [2, "CC3 channel is configured as input, IC3 is mapped on TI4"]
      B_0x3: [3, "CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
    CC4S:
      B_0x0: [0, CC4 channel is configured as output]
      B_0x1: [1, "CC4 channel is configured as input, IC4 is mapped on TI4"]
      B_0x2: [2, "CC4 channel is configured as input, IC4 is mapped on TI3"]
      B_0x3: [3, "CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
  TIM2_CCMR2_ALTERNATE:
    CC3S:
      B_0x0: [0, CC3 channel is configured as output]
      B_0x1: [1, "CC3 channel is configured as input, IC3 is mapped on TI3"]
      B_0x2: [2, "CC3 channel is configured as input, IC3 is mapped on TI4"]
      B_0x3: [3, "CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
    CC4S:
      B_0x0: [0, CC4 channel is configured as output]
      B_0x1: [1, "CC4 channel is configured as input, IC4 is mapped on TI4"]
      B_0x2: [2, "CC4 channel is configured as input, IC4 is mapped on TI3"]
      B_0x3: [3, "CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
  TIM2_CCER:
    CC1E:
      B_0x0: [0, Capture mode disabled / OC1 is not active]
      B_0x1: [1, Capture mode enabled / OC1 signal is output on the corresponding output pin]
    CC1P:
      B_0x0: [0, "OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)"]
      B_0x1: [1, "OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)"]
  TIM2_DCR:
    DBA:
      B_0x0: [0, TIMx_CR1]
      B_0x1: [1, TIMx_CR2]
      B_0x2: [2, TIMx_SMCR]
    DBL:
      B_0x0: [0, "1 transfer,"]
      B_0x1: [1, "2 transfers,"]
      B_0x2: [2, "3 transfers,"]
      B_0x11: [17, 18 transfers.]
  TIM2_AF1:
    ETRSEL:
      B_0x0: [0, ETR input is connected to I/O]
      B_0x1: [1, COMP1 output]
      B_0x2: [2, COMP2 output]
      B_0x3: [3, LSE]
      B_0x4: [4, SAI1 FS_A]
      B_0x5: [5, SAI1 FS_B]
  TIM2_TISEL:
    TI1SEL:
      B_0x0: [0, TIM2_CH1 input]
    TI2SEL:
      B_0x0: [0, TIM2_CH2 input]
    TI3SEL:
      B_0x0: [0, TIM2_CH3 input]
    TI4SEL:
      B_0x0: [0, TIM2_CH4 input]
      B_0x1: [1, COMP1 output]
      B_0x2: [2, COMP2 output]
      B_0x3: [3, COMP1 output OR COMP2 output]
TIM3:
  TIM3_CR1:
    CEN:
      B_0x0: [0, Counter disabled]
      B_0x1: [1, Counter enabled]
    UDIS:
      B_0x0: [0, "UEV enabled. The Update (UEV) event is generated by one of the following events:"]
      B_0x1: [1, "UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller."]
    URS:
      B_0x0: [0, "Any of the following events generate an update interrupt or DMA request if enabled. These events can be:"]
      B_0x1: [1, Only counter overflow/underflow generates an update interrupt or DMA request if enabled.]
    OPM:
      B_0x0: [0, Counter is not stopped at update event]
      B_0x1: [1, Counter stops counting at the next update event (clearing the bit CEN)]
    DIR:
      B_0x0: [0, Counter used as upcounter]
      B_0x1: [1, Counter used as downcounter]
    CMS:
      B_0x0: [0, Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).]
      B_0x1: [1, Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting down.]
      B_0x2: [2, Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting up.]
      B_0x3: [3, Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set both when the counter is counting up or down.]
    ARPE:
      B_0x0: [0, TIMx_ARR register is not buffered]
      B_0x1: [1, TIMx_ARR register is buffered]
    CKD:
      B_0x0: [0, t<sub>DTS</sub> = t<sub>CK_INT</sub>]
      B_0x1: [1, t<sub>DTS</sub> = 2   t<sub>CK_INT</sub>]
      B_0x2: [2, t<sub>DTS</sub> = 4   t<sub>CK_INT</sub>]
    UIFREMAP:
      B_0x0: [0, No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.]
      B_0x1: [1, Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.]
  TIM3_CR2:
    CCDS:
      B_0x0: [0, CCx DMA request sent when CCx event occurs]
      B_0x1: [1, CCx DMA requests sent when update event occurs]
    MMS:
      B_0x0: [0, Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.]
      B_0x1: [1, "Enable - the Counter enable signal, CNT_EN, is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic AND between CEN control bit and the trigger input when configured in gated mode."]
      B_0x2: [2, Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.]
      B_0x3: [3, "Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO)"]
      B_0x4: [4, Compare - OC1REFC signal is used as trigger output (TRGO)]
      B_0x5: [5, Compare - OC2REFC signal is used as trigger output (TRGO)]
      B_0x6: [6, Compare - OC3REFC signal is used as trigger output (TRGO)]
      B_0x7: [7, Compare - OC4REFC signal is used as trigger output (TRGO)]
    TI1S:
      B_0x0: [0, The TIMx_CH1 pin is connected to TI1 input]
      B_0x1: [1, "The TIMx_CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination) See also Section 24.3.25: Interfacing with Hall sensors on page 713"]
  TIM3_SMCR:
    SMS:
      B_0x0: [0, Slave mode disabled - if CEN =  1 then the prescaler is clocked directly by the internal clock.]
      B_0x1: [1, Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.]
      B_0x2: [2, Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.]
      B_0x3: [3, Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.]
      B_0x4: [4, Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.]
      B_0x5: [5, Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.]
      B_0x6: [6, Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.]
      B_0x7: [7, External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.]
    TS:
      B_0x0: [0, Internal Trigger 0 (ITR0)]
      B_0x1: [1, Internal Trigger 1 (ITR1)]
      B_0x2: [2, Internal Trigger 2 (ITR2)]
      B_0x3: [3, Internal Trigger 3 (ITR3)]
      B_0x4: [4, TI1 Edge Detector (TI1F_ED)]
      B_0x5: [5, Filtered Timer Input 1 (TI1FP1)]
      B_0x6: [6, Filtered Timer Input 2 (TI2FP2)]
      B_0x7: [7, External Trigger input (ETRF)]
    MSM:
      B_0x0: [0, No action]
      B_0x1: [1, The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.]
    ETF:
      B_0x0: [0, "No filter, sampling is done at f<sub>DTS</sub>"]
      B_0x1: [1, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=2"]
      B_0x2: [2, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=4"]
      B_0x3: [3, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=8"]
      B_0x4: [4, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=6"]
      B_0x5: [5, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=8"]
      B_0x6: [6, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=6"]
      B_0x7: [7, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=8"]
      B_0x8: [8, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=6"]
      B_0x9: [9, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=8"]
      B_0xA: [10, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=5"]
      B_0xB: [11, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=6"]
      B_0xC: [12, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=8"]
      B_0xD: [13, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=5"]
      B_0xE: [14, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=6"]
      B_0xF: [15, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=8"]
    ETPS:
      B_0x0: [0, Prescaler OFF]
      B_0x1: [1, ETRP frequency divided by 2]
      B_0x2: [2, ETRP frequency divided by 4]
      B_0x3: [3, ETRP frequency divided by 8]
    ECE:
      B_0x0: [0, External clock mode 2 disabled]
      B_0x1: [1, External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.]
    ETP:
      B_0x0: [0, "ETR is non-inverted, active at high level or rising edge"]
      B_0x1: [1, "ETR is inverted, active at low level or falling edge"]
  TIM3_DIER:
    UIE:
      B_0x0: [0, Update interrupt disabled.]
      B_0x1: [1, Update interrupt enabled.]
    CC1IE:
      B_0x0: [0, CC1 interrupt disabled.]
      B_0x1: [1, CC1 interrupt enabled.]
    CC2IE:
      B_0x0: [0, CC2 interrupt disabled.]
      B_0x1: [1, CC2 interrupt enabled.]
    CC3IE:
      B_0x0: [0, CC3 interrupt disabled.]
      B_0x1: [1, CC3 interrupt enabled.]
    CC4IE:
      B_0x0: [0, CC4 interrupt disabled.]
      B_0x1: [1, CC4 interrupt enabled.]
    TIE:
      B_0x0: [0, Trigger interrupt disabled.]
      B_0x1: [1, Trigger interrupt enabled.]
    UDE:
      B_0x0: [0, Update DMA request disabled.]
      B_0x1: [1, Update DMA request enabled.]
    CC1DE:
      B_0x0: [0, CC1 DMA request disabled.]
      B_0x1: [1, CC1 DMA request enabled.]
    CC2DE:
      B_0x0: [0, CC2 DMA request disabled.]
      B_0x1: [1, CC2 DMA request enabled.]
    CC3DE:
      B_0x0: [0, CC3 DMA request disabled.]
      B_0x1: [1, CC3 DMA request enabled.]
    CC4DE:
      B_0x0: [0, CC4 DMA request disabled.]
      B_0x1: [1, CC4 DMA request enabled.]
    TDE:
      B_0x0: [0, Trigger DMA request disabled.]
      B_0x1: [1, Trigger DMA request enabled.]
  TIM3_SR:
    UIF:
      B_0x0: [0, No update occurred]
      B_0x1: [1, "Update interrupt pending. This bit is set by hardware when the registers are updated:"]
    CC1IF:
      B_0x0: [0, No compare match / No input capture occurred]
      B_0x1: [1, A compare match or an input capture occurred]
    TIF:
      B_0x0: [0, No trigger event occurred.]
      B_0x1: [1, Trigger interrupt pending.]
    CC1OF:
      B_0x0: [0, No overcapture has been detected.]
      B_0x1: [1, The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set]
  TIM3_EGR:
    UG:
      B_0x0: [0, No action]
      B_0x1: [1, "Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (TIMx_ARR) if DIR=1 (downcounting)."]
    CC1G:
      B_0x0: [0, No action]
      B_0x1: [1, "A capture/compare event is generated on channel 1:"]
    TG:
      B_0x0: [0, No action]
      B_0x1: [1, The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.]
  TIM3_CCMR1:
    CC1S:
      B_0x0: [0, CC1 channel is configured as output]
      B_0x1: [1, "CC1 channel is configured as input, IC1 is mapped on TI1"]
      B_0x2: [2, "CC1 channel is configured as input, IC1 is mapped on TI2"]
      B_0x3: [3, "CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
    IC1PSC:
      B_0x0: [0, "no prescaler, capture is done each time an edge is detected on the capture input"]
      B_0x1: [1, capture is done once every 2 events]
      B_0x2: [2, capture is done once every 4 events]
      B_0x3: [3, capture is done once every 8 events]
    IC1F:
      B_0x0: [0, "No filter, sampling is done at f\t\t<sub>DTS</sub>"]
      B_0x1: [1, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=2"]
      B_0x2: [2, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=4"]
      B_0x3: [3, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=8"]
      B_0x4: [4, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=6"]
      B_0x5: [5, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=8"]
      B_0x6: [6, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=6"]
      B_0x7: [7, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=8"]
      B_0x8: [8, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=6"]
      B_0x9: [9, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=8"]
      B_0xA: [10, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=5"]
      B_0xB: [11, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=6"]
      B_0xC: [12, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=8"]
      B_0xD: [13, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=5"]
      B_0xE: [14, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=6"]
      B_0xF: [15, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=8"]
    CC2S:
      B_0x0: [0, CC2 channel is configured as output.]
      B_0x1: [1, "CC2 channel is configured as input, IC2 is mapped on TI2."]
      B_0x2: [2, "CC2 channel is configured as input, IC2 is mapped on TI1."]
      B_0x3: [3, "CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
  TIM3_CCMR1_ALTERNATE:
    CC1S:
      B_0x0: [0, CC1 channel is configured as output.]
      B_0x1: [1, "CC1 channel is configured as input, IC1 is mapped on TI1."]
      B_0x2: [2, "CC1 channel is configured as input, IC1 is mapped on TI2."]
      B_0x3: [3, "CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
    OC1FE:
      B_0x0: [0, CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.]
      B_0x1: [1, "An active edge on the trigger input acts like a compare match on CC1 output. Then, OC is set to the compare level independently from the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OCFE acts only if the channel is configured in PWM1 or PWM2 mode."]
    OC1PE:
      B_0x0: [0, "Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately."]
      B_0x1: [1, Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.]
    OC1M:
      B_0x0: [0, "Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs. This mode can be used when the timer serves as a software timebase. When the frozen mode is enabled during timer operation, the output keeps the state (active or inactive) it had before entering the frozen state."]
      B_0x1: [1, Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).]
      B_0x2: [2, Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).]
      B_0x3: [3, Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.]
      B_0x4: [4, Force inactive level - OC1REF is forced low.]
      B_0x5: [5, Force active level - OC1REF is forced high.]
      B_0x6: [6, "PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT<TIMx_CCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF= 0) as long as TIMx_CNT>TIMx_CCR1 else active (OC1REF=1)."]
      B_0x7: [7, "PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT<TIMx_CCR1 else active. In downcounting, channel 1 is active as long as TIMx_CNT>TIMx_CCR1 else inactive."]
    OC1CE:
      B_0x0: [0, OC1Ref is not affected by the ETRF input]
      B_0x1: [1, OC1Ref is cleared as soon as a High level is detected on ETRF input]
    CC2S:
      B_0x0: [0, CC2 channel is configured as output]
      B_0x1: [1, "CC2 channel is configured as input, IC2 is mapped on TI2"]
      B_0x2: [2, "CC2 channel is configured as input, IC2 is mapped on TI1"]
      B_0x3: [3, "CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through the TS bit (TIMx_SMCR register)"]
  TIM3_CCMR2:
    CC3S:
      B_0x0: [0, CC3 channel is configured as output]
      B_0x1: [1, "CC3 channel is configured as input, IC3 is mapped on TI3"]
      B_0x2: [2, "CC3 channel is configured as input, IC3 is mapped on TI4"]
      B_0x3: [3, "CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
    CC4S:
      B_0x0: [0, CC4 channel is configured as output]
      B_0x1: [1, "CC4 channel is configured as input, IC4 is mapped on TI4"]
      B_0x2: [2, "CC4 channel is configured as input, IC4 is mapped on TI3"]
      B_0x3: [3, "CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
  TIM3_CCMR2_ALTERNATE:
    CC3S:
      B_0x0: [0, CC3 channel is configured as output]
      B_0x1: [1, "CC3 channel is configured as input, IC3 is mapped on TI3"]
      B_0x2: [2, "CC3 channel is configured as input, IC3 is mapped on TI4"]
      B_0x3: [3, "CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
    CC4S:
      B_0x0: [0, CC4 channel is configured as output]
      B_0x1: [1, "CC4 channel is configured as input, IC4 is mapped on TI4"]
      B_0x2: [2, "CC4 channel is configured as input, IC4 is mapped on TI3"]
      B_0x3: [3, "CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
  TIM3_CCER:
    CC1E:
      B_0x0: [0, Capture mode disabled / OC1 is not active]
      B_0x1: [1, Capture mode enabled / OC1 signal is output on the corresponding output pin]
    CC1P:
      B_0x0: [0, "OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)"]
      B_0x1: [1, "OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)"]
  TIM3_DCR:
    DBA:
      B_0x0: [0, TIMx_CR1]
      B_0x1: [1, TIMx_CR2]
      B_0x2: [2, TIMx_SMCR]
    DBL:
      B_0x0: [0, "1 transfer,"]
      B_0x1: [1, "2 transfers,"]
      B_0x2: [2, "3 transfers,"]
      B_0x11: [17, 18 transfers.]
  TIM3_AF1:
    ETRSEL:
      B_0x0: [0, ETR input is connected to I/O]
      B_0x1: [1, COMP1 output]
  TIM3_TISEL:
    TI1SEL:
      B_0x0: [0, TIM3_CH1 input]
      B_0x1: [1, COMP1 output]
      B_0x2: [2, COMP2 output]
      B_0x3: [3, COMP1 output OR COMP2 output]
    TI2SEL:
      B_0x0: [0, TIM3_CH2 input]
    TI3SEL:
      B_0x0: [0, TIM3_CH3 input]
    TI4SEL:
      B_0x0: [0, TIM3_CH4 input]
TIM4:
  TIM4_CR1:
    CEN:
      B_0x0: [0, Counter disabled]
      B_0x1: [1, Counter enabled]
    UDIS:
      B_0x0: [0, "UEV enabled. The Update (UEV) event is generated by one of the following events:"]
      B_0x1: [1, "UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller."]
    URS:
      B_0x0: [0, "Any of the following events generate an update interrupt or DMA request if enabled. These events can be:"]
      B_0x1: [1, Only counter overflow/underflow generates an update interrupt or DMA request if enabled.]
    OPM:
      B_0x0: [0, Counter is not stopped at update event]
      B_0x1: [1, Counter stops counting at the next update event (clearing the bit CEN)]
    DIR:
      B_0x0: [0, Counter used as upcounter]
      B_0x1: [1, Counter used as downcounter]
    CMS:
      B_0x0: [0, Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).]
      B_0x1: [1, Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting down.]
      B_0x2: [2, Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting up.]
      B_0x3: [3, Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set both when the counter is counting up or down.]
    ARPE:
      B_0x0: [0, TIMx_ARR register is not buffered]
      B_0x1: [1, TIMx_ARR register is buffered]
    CKD:
      B_0x0: [0, t<sub>DTS</sub> = t<sub>CK_INT</sub>]
      B_0x1: [1, t<sub>DTS</sub> = 2   t<sub>CK_INT</sub>]
      B_0x2: [2, t<sub>DTS</sub> = 4   t<sub>CK_INT</sub>]
    UIFREMAP:
      B_0x0: [0, No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.]
      B_0x1: [1, Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.]
  TIM4_CR2:
    CCDS:
      B_0x0: [0, CCx DMA request sent when CCx event occurs]
      B_0x1: [1, CCx DMA requests sent when update event occurs]
    MMS:
      B_0x0: [0, Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.]
      B_0x1: [1, "Enable - the Counter enable signal, CNT_EN, is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic AND between CEN control bit and the trigger input when configured in gated mode."]
      B_0x2: [2, Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.]
      B_0x3: [3, "Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO)"]
      B_0x4: [4, Compare - OC1REFC signal is used as trigger output (TRGO)]
      B_0x5: [5, Compare - OC2REFC signal is used as trigger output (TRGO)]
      B_0x6: [6, Compare - OC3REFC signal is used as trigger output (TRGO)]
      B_0x7: [7, Compare - OC4REFC signal is used as trigger output (TRGO)]
    TI1S:
      B_0x0: [0, The TIMx_CH1 pin is connected to TI1 input]
      B_0x1: [1, "The TIMx_CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination) See also Section 24.3.25: Interfacing with Hall sensors on page 713"]
  TIM4_SMCR:
    SMS:
      B_0x0: [0, Slave mode disabled - if CEN =  1 then the prescaler is clocked directly by the internal clock.]
      B_0x1: [1, Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.]
      B_0x2: [2, Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.]
      B_0x3: [3, Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.]
      B_0x4: [4, Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.]
      B_0x5: [5, Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.]
      B_0x6: [6, Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.]
      B_0x7: [7, External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.]
    TS:
      B_0x0: [0, Internal Trigger 0 (ITR0)]
      B_0x1: [1, Internal Trigger 1 (ITR1)]
      B_0x2: [2, Internal Trigger 2 (ITR2)]
      B_0x3: [3, Internal Trigger 3 (ITR3)]
      B_0x4: [4, TI1 Edge Detector (TI1F_ED)]
      B_0x5: [5, Filtered Timer Input 1 (TI1FP1)]
      B_0x6: [6, Filtered Timer Input 2 (TI2FP2)]
      B_0x7: [7, External Trigger input (ETRF)]
    MSM:
      B_0x0: [0, No action]
      B_0x1: [1, The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.]
    ETF:
      B_0x0: [0, "No filter, sampling is done at f<sub>DTS</sub>"]
      B_0x1: [1, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=2"]
      B_0x2: [2, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=4"]
      B_0x3: [3, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=8"]
      B_0x4: [4, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=6"]
      B_0x5: [5, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=8"]
      B_0x6: [6, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=6"]
      B_0x7: [7, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=8"]
      B_0x8: [8, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=6"]
      B_0x9: [9, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=8"]
      B_0xA: [10, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=5"]
      B_0xB: [11, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=6"]
      B_0xC: [12, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=8"]
      B_0xD: [13, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=5"]
      B_0xE: [14, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=6"]
      B_0xF: [15, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=8"]
    ETPS:
      B_0x0: [0, Prescaler OFF]
      B_0x1: [1, ETRP frequency divided by 2]
      B_0x2: [2, ETRP frequency divided by 4]
      B_0x3: [3, ETRP frequency divided by 8]
    ECE:
      B_0x0: [0, External clock mode 2 disabled]
      B_0x1: [1, External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.]
    ETP:
      B_0x0: [0, "ETR is non-inverted, active at high level or rising edge"]
      B_0x1: [1, "ETR is inverted, active at low level or falling edge"]
  TIM4_DIER:
    UIE:
      B_0x0: [0, Update interrupt disabled.]
      B_0x1: [1, Update interrupt enabled.]
    CC1IE:
      B_0x0: [0, CC1 interrupt disabled.]
      B_0x1: [1, CC1 interrupt enabled.]
    CC2IE:
      B_0x0: [0, CC2 interrupt disabled.]
      B_0x1: [1, CC2 interrupt enabled.]
    CC3IE:
      B_0x0: [0, CC3 interrupt disabled.]
      B_0x1: [1, CC3 interrupt enabled.]
    CC4IE:
      B_0x0: [0, CC4 interrupt disabled.]
      B_0x1: [1, CC4 interrupt enabled.]
    TIE:
      B_0x0: [0, Trigger interrupt disabled.]
      B_0x1: [1, Trigger interrupt enabled.]
    UDE:
      B_0x0: [0, Update DMA request disabled.]
      B_0x1: [1, Update DMA request enabled.]
    CC1DE:
      B_0x0: [0, CC1 DMA request disabled.]
      B_0x1: [1, CC1 DMA request enabled.]
    CC2DE:
      B_0x0: [0, CC2 DMA request disabled.]
      B_0x1: [1, CC2 DMA request enabled.]
    CC3DE:
      B_0x0: [0, CC3 DMA request disabled.]
      B_0x1: [1, CC3 DMA request enabled.]
    CC4DE:
      B_0x0: [0, CC4 DMA request disabled.]
      B_0x1: [1, CC4 DMA request enabled.]
    TDE:
      B_0x0: [0, Trigger DMA request disabled.]
      B_0x1: [1, Trigger DMA request enabled.]
  TIM4_SR:
    UIF:
      B_0x0: [0, No update occurred]
      B_0x1: [1, "Update interrupt pending. This bit is set by hardware when the registers are updated:"]
    CC1IF:
      B_0x0: [0, No compare match / No input capture occurred]
      B_0x1: [1, A compare match or an input capture occurred]
    TIF:
      B_0x0: [0, No trigger event occurred.]
      B_0x1: [1, Trigger interrupt pending.]
    CC1OF:
      B_0x0: [0, No overcapture has been detected.]
      B_0x1: [1, The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set]
  TIM4_EGR:
    UG:
      B_0x0: [0, No action]
      B_0x1: [1, "Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (TIMx_ARR) if DIR=1 (downcounting)."]
    CC1G:
      B_0x0: [0, No action]
      B_0x1: [1, "A capture/compare event is generated on channel 1:"]
    TG:
      B_0x0: [0, No action]
      B_0x1: [1, The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.]
  TIM4_CCMR1:
    CC1S:
      B_0x0: [0, CC1 channel is configured as output]
      B_0x1: [1, "CC1 channel is configured as input, IC1 is mapped on TI1"]
      B_0x2: [2, "CC1 channel is configured as input, IC1 is mapped on TI2"]
      B_0x3: [3, "CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
    IC1PSC:
      B_0x0: [0, "no prescaler, capture is done each time an edge is detected on the capture input"]
      B_0x1: [1, capture is done once every 2 events]
      B_0x2: [2, capture is done once every 4 events]
      B_0x3: [3, capture is done once every 8 events]
    IC1F:
      B_0x0: [0, "No filter, sampling is done at f\t\t<sub>DTS</sub>"]
      B_0x1: [1, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=2"]
      B_0x2: [2, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=4"]
      B_0x3: [3, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=8"]
      B_0x4: [4, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=6"]
      B_0x5: [5, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=8"]
      B_0x6: [6, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=6"]
      B_0x7: [7, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=8"]
      B_0x8: [8, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=6"]
      B_0x9: [9, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=8"]
      B_0xA: [10, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=5"]
      B_0xB: [11, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=6"]
      B_0xC: [12, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=8"]
      B_0xD: [13, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=5"]
      B_0xE: [14, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=6"]
      B_0xF: [15, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=8"]
    CC2S:
      B_0x0: [0, CC2 channel is configured as output.]
      B_0x1: [1, "CC2 channel is configured as input, IC2 is mapped on TI2."]
      B_0x2: [2, "CC2 channel is configured as input, IC2 is mapped on TI1."]
      B_0x3: [3, "CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
  TIM4_CCMR1_ALTERNATE:
    CC1S:
      B_0x0: [0, CC1 channel is configured as output.]
      B_0x1: [1, "CC1 channel is configured as input, IC1 is mapped on TI1."]
      B_0x2: [2, "CC1 channel is configured as input, IC1 is mapped on TI2."]
      B_0x3: [3, "CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
    OC1FE:
      B_0x0: [0, CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.]
      B_0x1: [1, "An active edge on the trigger input acts like a compare match on CC1 output. Then, OC is set to the compare level independently from the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OCFE acts only if the channel is configured in PWM1 or PWM2 mode."]
    OC1PE:
      B_0x0: [0, "Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately."]
      B_0x1: [1, Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.]
    OC1M:
      B_0x0: [0, "Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs. This mode can be used when the timer serves as a software timebase. When the frozen mode is enabled during timer operation, the output keeps the state (active or inactive) it had before entering the frozen state."]
      B_0x1: [1, Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).]
      B_0x2: [2, Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).]
      B_0x3: [3, Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.]
      B_0x4: [4, Force inactive level - OC1REF is forced low.]
      B_0x5: [5, Force active level - OC1REF is forced high.]
      B_0x6: [6, "PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT<TIMx_CCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF= 0) as long as TIMx_CNT>TIMx_CCR1 else active (OC1REF=1)."]
      B_0x7: [7, "PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT<TIMx_CCR1 else active. In downcounting, channel 1 is active as long as TIMx_CNT>TIMx_CCR1 else inactive."]
    OC1CE:
      B_0x0: [0, OC1Ref is not affected by the ETRF input]
      B_0x1: [1, OC1Ref is cleared as soon as a High level is detected on ETRF input]
    CC2S:
      B_0x0: [0, CC2 channel is configured as output]
      B_0x1: [1, "CC2 channel is configured as input, IC2 is mapped on TI2"]
      B_0x2: [2, "CC2 channel is configured as input, IC2 is mapped on TI1"]
      B_0x3: [3, "CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through the TS bit (TIMx_SMCR register)"]
  TIM4_CCMR2:
    CC3S:
      B_0x0: [0, CC3 channel is configured as output]
      B_0x1: [1, "CC3 channel is configured as input, IC3 is mapped on TI3"]
      B_0x2: [2, "CC3 channel is configured as input, IC3 is mapped on TI4"]
      B_0x3: [3, "CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
    CC4S:
      B_0x0: [0, CC4 channel is configured as output]
      B_0x1: [1, "CC4 channel is configured as input, IC4 is mapped on TI4"]
      B_0x2: [2, "CC4 channel is configured as input, IC4 is mapped on TI3"]
      B_0x3: [3, "CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
  TIM4_CCMR2_ALTERNATE:
    CC3S:
      B_0x0: [0, CC3 channel is configured as output]
      B_0x1: [1, "CC3 channel is configured as input, IC3 is mapped on TI3"]
      B_0x2: [2, "CC3 channel is configured as input, IC3 is mapped on TI4"]
      B_0x3: [3, "CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
    CC4S:
      B_0x0: [0, CC4 channel is configured as output]
      B_0x1: [1, "CC4 channel is configured as input, IC4 is mapped on TI4"]
      B_0x2: [2, "CC4 channel is configured as input, IC4 is mapped on TI3"]
      B_0x3: [3, "CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
  TIM4_CCER:
    CC1E:
      B_0x0: [0, Capture mode disabled / OC1 is not active]
      B_0x1: [1, Capture mode enabled / OC1 signal is output on the corresponding output pin]
    CC1P:
      B_0x0: [0, "OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)"]
      B_0x1: [1, "OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)"]
  TIM4_DCR:
    DBA:
      B_0x0: [0, TIMx_CR1]
      B_0x1: [1, TIMx_CR2]
      B_0x2: [2, TIMx_SMCR]
    DBL:
      B_0x0: [0, "1 transfer,"]
      B_0x1: [1, "2 transfers,"]
      B_0x2: [2, "3 transfers,"]
      B_0x11: [17, 18 transfers.]
  TIM4_AF1:
    ETRSEL:
      B_0x0: [0, ETR input is connected to I/O]
  TIM4_TISEL:
    TI1SEL:
      B_0x0: [0, TIM4_CH1 input]
    TI2SEL:
      B_0x0: [0, TIM4_CH2 input]
    TI3SEL:
      B_0x0: [0, TIM4_CH3 input]
    TI4SEL:
      B_0x0: [0, TIM4_CH4 input]
TIM5:
  TIM5_CR1:
    CEN:
      B_0x0: [0, Counter disabled]
      B_0x1: [1, Counter enabled]
    UDIS:
      B_0x0: [0, "UEV enabled. The Update (UEV) event is generated by one of the following events:"]
      B_0x1: [1, "UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller."]
    URS:
      B_0x0: [0, "Any of the following events generate an update interrupt or DMA request if enabled. These events can be:"]
      B_0x1: [1, Only counter overflow/underflow generates an update interrupt or DMA request if enabled.]
    OPM:
      B_0x0: [0, Counter is not stopped at update event]
      B_0x1: [1, Counter stops counting at the next update event (clearing the bit CEN)]
    DIR:
      B_0x0: [0, Counter used as upcounter]
      B_0x1: [1, Counter used as downcounter]
    CMS:
      B_0x0: [0, Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).]
      B_0x1: [1, Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting down.]
      B_0x2: [2, Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting up.]
      B_0x3: [3, Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set both when the counter is counting up or down.]
    ARPE:
      B_0x0: [0, TIMx_ARR register is not buffered]
      B_0x1: [1, TIMx_ARR register is buffered]
    CKD:
      B_0x0: [0, t<sub>DTS</sub> = t<sub>CK_INT</sub>]
      B_0x1: [1, t<sub>DTS</sub> = 2   t<sub>CK_INT</sub>]
      B_0x2: [2, t<sub>DTS</sub> = 4   t<sub>CK_INT</sub>]
    UIFREMAP:
      B_0x0: [0, No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.]
      B_0x1: [1, Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.]
  TIM5_CR2:
    CCDS:
      B_0x0: [0, CCx DMA request sent when CCx event occurs]
      B_0x1: [1, CCx DMA requests sent when update event occurs]
    MMS:
      B_0x0: [0, Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.]
      B_0x1: [1, "Enable - the Counter enable signal, CNT_EN, is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic AND between CEN control bit and the trigger input when configured in gated mode."]
      B_0x2: [2, Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.]
      B_0x3: [3, "Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO)"]
      B_0x4: [4, Compare - OC1REFC signal is used as trigger output (TRGO)]
      B_0x5: [5, Compare - OC2REFC signal is used as trigger output (TRGO)]
      B_0x6: [6, Compare - OC3REFC signal is used as trigger output (TRGO)]
      B_0x7: [7, Compare - OC4REFC signal is used as trigger output (TRGO)]
    TI1S:
      B_0x0: [0, The TIMx_CH1 pin is connected to TI1 input]
      B_0x1: [1, "The TIMx_CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination) See also Section 24.3.25: Interfacing with Hall sensors on page 713"]
  TIM5_SMCR:
    SMS:
      B_0x0: [0, Slave mode disabled - if CEN =  1 then the prescaler is clocked directly by the internal clock.]
      B_0x1: [1, Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.]
      B_0x2: [2, Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.]
      B_0x3: [3, Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.]
      B_0x4: [4, Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.]
      B_0x5: [5, Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.]
      B_0x6: [6, Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.]
      B_0x7: [7, External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.]
    TS:
      B_0x0: [0, Internal Trigger 0 (ITR0)]
      B_0x1: [1, Internal Trigger 1 (ITR1)]
      B_0x2: [2, Internal Trigger 2 (ITR2)]
      B_0x3: [3, Internal Trigger 3 (ITR3)]
      B_0x4: [4, TI1 Edge Detector (TI1F_ED)]
      B_0x5: [5, Filtered Timer Input 1 (TI1FP1)]
      B_0x6: [6, Filtered Timer Input 2 (TI2FP2)]
      B_0x7: [7, External Trigger input (ETRF)]
    MSM:
      B_0x0: [0, No action]
      B_0x1: [1, The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.]
    ETF:
      B_0x0: [0, "No filter, sampling is done at f<sub>DTS</sub>"]
      B_0x1: [1, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=2"]
      B_0x2: [2, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=4"]
      B_0x3: [3, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=8"]
      B_0x4: [4, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=6"]
      B_0x5: [5, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=8"]
      B_0x6: [6, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=6"]
      B_0x7: [7, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=8"]
      B_0x8: [8, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=6"]
      B_0x9: [9, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=8"]
      B_0xA: [10, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=5"]
      B_0xB: [11, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=6"]
      B_0xC: [12, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=8"]
      B_0xD: [13, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=5"]
      B_0xE: [14, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=6"]
      B_0xF: [15, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=8"]
    ETPS:
      B_0x0: [0, Prescaler OFF]
      B_0x1: [1, ETRP frequency divided by 2]
      B_0x2: [2, ETRP frequency divided by 4]
      B_0x3: [3, ETRP frequency divided by 8]
    ECE:
      B_0x0: [0, External clock mode 2 disabled]
      B_0x1: [1, External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.]
    ETP:
      B_0x0: [0, "ETR is non-inverted, active at high level or rising edge"]
      B_0x1: [1, "ETR is inverted, active at low level or falling edge"]
  TIM5_DIER:
    UIE:
      B_0x0: [0, Update interrupt disabled.]
      B_0x1: [1, Update interrupt enabled.]
    CC1IE:
      B_0x0: [0, CC1 interrupt disabled.]
      B_0x1: [1, CC1 interrupt enabled.]
    CC2IE:
      B_0x0: [0, CC2 interrupt disabled.]
      B_0x1: [1, CC2 interrupt enabled.]
    CC3IE:
      B_0x0: [0, CC3 interrupt disabled.]
      B_0x1: [1, CC3 interrupt enabled.]
    CC4IE:
      B_0x0: [0, CC4 interrupt disabled.]
      B_0x1: [1, CC4 interrupt enabled.]
    TIE:
      B_0x0: [0, Trigger interrupt disabled.]
      B_0x1: [1, Trigger interrupt enabled.]
    UDE:
      B_0x0: [0, Update DMA request disabled.]
      B_0x1: [1, Update DMA request enabled.]
    CC1DE:
      B_0x0: [0, CC1 DMA request disabled.]
      B_0x1: [1, CC1 DMA request enabled.]
    CC2DE:
      B_0x0: [0, CC2 DMA request disabled.]
      B_0x1: [1, CC2 DMA request enabled.]
    CC3DE:
      B_0x0: [0, CC3 DMA request disabled.]
      B_0x1: [1, CC3 DMA request enabled.]
    CC4DE:
      B_0x0: [0, CC4 DMA request disabled.]
      B_0x1: [1, CC4 DMA request enabled.]
    TDE:
      B_0x0: [0, Trigger DMA request disabled.]
      B_0x1: [1, Trigger DMA request enabled.]
  TIM5_SR:
    UIF:
      B_0x0: [0, No update occurred]
      B_0x1: [1, "Update interrupt pending. This bit is set by hardware when the registers are updated:"]
    CC1IF:
      B_0x0: [0, No compare match / No input capture occurred]
      B_0x1: [1, A compare match or an input capture occurred]
    TIF:
      B_0x0: [0, No trigger event occurred.]
      B_0x1: [1, Trigger interrupt pending.]
    CC1OF:
      B_0x0: [0, No overcapture has been detected.]
      B_0x1: [1, The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set]
  TIM5_EGR:
    UG:
      B_0x0: [0, No action]
      B_0x1: [1, "Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (TIMx_ARR) if DIR=1 (downcounting)."]
    CC1G:
      B_0x0: [0, No action]
      B_0x1: [1, "A capture/compare event is generated on channel 1:"]
    TG:
      B_0x0: [0, No action]
      B_0x1: [1, The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.]
  TIM5_CCMR1:
    CC1S:
      B_0x0: [0, CC1 channel is configured as output]
      B_0x1: [1, "CC1 channel is configured as input, IC1 is mapped on TI1"]
      B_0x2: [2, "CC1 channel is configured as input, IC1 is mapped on TI2"]
      B_0x3: [3, "CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
    IC1PSC:
      B_0x0: [0, "no prescaler, capture is done each time an edge is detected on the capture input"]
      B_0x1: [1, capture is done once every 2 events]
      B_0x2: [2, capture is done once every 4 events]
      B_0x3: [3, capture is done once every 8 events]
    IC1F:
      B_0x0: [0, "No filter, sampling is done at f\t\t<sub>DTS</sub>"]
      B_0x1: [1, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=2"]
      B_0x2: [2, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=4"]
      B_0x3: [3, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=8"]
      B_0x4: [4, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=6"]
      B_0x5: [5, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=8"]
      B_0x6: [6, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=6"]
      B_0x7: [7, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=8"]
      B_0x8: [8, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=6"]
      B_0x9: [9, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=8"]
      B_0xA: [10, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=5"]
      B_0xB: [11, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=6"]
      B_0xC: [12, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=8"]
      B_0xD: [13, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=5"]
      B_0xE: [14, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=6"]
      B_0xF: [15, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=8"]
    CC2S:
      B_0x0: [0, CC2 channel is configured as output.]
      B_0x1: [1, "CC2 channel is configured as input, IC2 is mapped on TI2."]
      B_0x2: [2, "CC2 channel is configured as input, IC2 is mapped on TI1."]
      B_0x3: [3, "CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
  TIM5_CCMR1_ALTERNATE:
    CC1S:
      B_0x0: [0, CC1 channel is configured as output.]
      B_0x1: [1, "CC1 channel is configured as input, IC1 is mapped on TI1."]
      B_0x2: [2, "CC1 channel is configured as input, IC1 is mapped on TI2."]
      B_0x3: [3, "CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
    OC1FE:
      B_0x0: [0, CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.]
      B_0x1: [1, "An active edge on the trigger input acts like a compare match on CC1 output. Then, OC is set to the compare level independently from the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OCFE acts only if the channel is configured in PWM1 or PWM2 mode."]
    OC1PE:
      B_0x0: [0, "Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately."]
      B_0x1: [1, Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.]
    OC1M:
      B_0x0: [0, "Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs. This mode can be used when the timer serves as a software timebase. When the frozen mode is enabled during timer operation, the output keeps the state (active or inactive) it had before entering the frozen state."]
      B_0x1: [1, Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).]
      B_0x2: [2, Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).]
      B_0x3: [3, Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.]
      B_0x4: [4, Force inactive level - OC1REF is forced low.]
      B_0x5: [5, Force active level - OC1REF is forced high.]
      B_0x6: [6, "PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT<TIMx_CCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF= 0) as long as TIMx_CNT>TIMx_CCR1 else active (OC1REF=1)."]
      B_0x7: [7, "PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT<TIMx_CCR1 else active. In downcounting, channel 1 is active as long as TIMx_CNT>TIMx_CCR1 else inactive."]
    OC1CE:
      B_0x0: [0, OC1Ref is not affected by the ETRF input]
      B_0x1: [1, OC1Ref is cleared as soon as a High level is detected on ETRF input]
    CC2S:
      B_0x0: [0, CC2 channel is configured as output]
      B_0x1: [1, "CC2 channel is configured as input, IC2 is mapped on TI2"]
      B_0x2: [2, "CC2 channel is configured as input, IC2 is mapped on TI1"]
      B_0x3: [3, "CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through the TS bit (TIMx_SMCR register)"]
  TIM5_CCMR2:
    CC3S:
      B_0x0: [0, CC3 channel is configured as output]
      B_0x1: [1, "CC3 channel is configured as input, IC3 is mapped on TI3"]
      B_0x2: [2, "CC3 channel is configured as input, IC3 is mapped on TI4"]
      B_0x3: [3, "CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
    CC4S:
      B_0x0: [0, CC4 channel is configured as output]
      B_0x1: [1, "CC4 channel is configured as input, IC4 is mapped on TI4"]
      B_0x2: [2, "CC4 channel is configured as input, IC4 is mapped on TI3"]
      B_0x3: [3, "CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
  TIM5_CCMR2_ALTERNATE:
    CC3S:
      B_0x0: [0, CC3 channel is configured as output]
      B_0x1: [1, "CC3 channel is configured as input, IC3 is mapped on TI3"]
      B_0x2: [2, "CC3 channel is configured as input, IC3 is mapped on TI4"]
      B_0x3: [3, "CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
    CC4S:
      B_0x0: [0, CC4 channel is configured as output]
      B_0x1: [1, "CC4 channel is configured as input, IC4 is mapped on TI4"]
      B_0x2: [2, "CC4 channel is configured as input, IC4 is mapped on TI3"]
      B_0x3: [3, "CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
  TIM5_CCER:
    CC1E:
      B_0x0: [0, Capture mode disabled / OC1 is not active]
      B_0x1: [1, Capture mode enabled / OC1 signal is output on the corresponding output pin]
    CC1P:
      B_0x0: [0, "OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)"]
      B_0x1: [1, "OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)"]
  TIM5_DCR:
    DBA:
      B_0x0: [0, TIMx_CR1]
      B_0x1: [1, TIMx_CR2]
      B_0x2: [2, TIMx_SMCR]
    DBL:
      B_0x0: [0, "1 transfer,"]
      B_0x1: [1, "2 transfers,"]
      B_0x2: [2, "3 transfers,"]
      B_0x11: [17, 18 transfers.]
  TIM5_AF1:
    ETRSEL:
      B_0x0: [0, ETR input is connected to I/O]
      B_0x1: [1, SAI2 FS_A connected to ETR input]
      B_0x2: [2, SAI2 FS_B connected to ETR input]
  TIM5_TISEL:
    TI1SEL:
      B_0x0: [0, TIM5_CH1 input]
      B_0x1: [1, fdcan1_tmp]
      B_0x2: [2, fdcan1_rtp]
    TI2SEL:
      B_0x0: [0, TIM5_CH2 input]
    TI3SEL:
      B_0x0: [0, TIM5_CH3 input]
    TI4SEL:
      B_0x0: [0, TIM5_CH4 input]
TIM6:
  TIM6_CR1:
    CEN:
      B_0x0: [0, Counter disabled]
      B_0x1: [1, Counter enabled]
    UDIS:
      B_0x0: [0, "UEV enabled. The Update (UEV) event is generated by one of the following events:"]
      B_0x1: [1, "UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller."]
    URS:
      B_0x0: [0, "Any of the following events generates an update interrupt or DMA request if enabled. These events can be:"]
      B_0x1: [1, Only counter overflow/underflow generates an update interrupt or DMA request if enabled.]
    OPM:
      B_0x0: [0, Counter is not stopped at update event]
      B_0x1: [1, Counter stops counting at the next update event (clearing the CEN bit).]
    ARPE:
      B_0x0: [0, TIMx_ARR register is not buffered.]
      B_0x1: [1, TIMx_ARR register is buffered.]
    UIFREMAP:
      B_0x0: [0, No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.]
      B_0x1: [1, Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.]
  TIM6_CR2:
    MMS:
      B_0x0: [0, Reset - the UG bit from the TIMx_EGR register is used as a trigger output (TRGO). If reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.]
      B_0x1: [1, "Enable - the Counter enable signal, CNT_EN, is used as a trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode."]
      B_0x2: [2, Update - The update event is selected as a trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.]
  TIM6_DIER:
    UIE:
      B_0x0: [0, Update interrupt disabled.]
      B_0x1: [1, Update interrupt enabled.]
    UDE:
      B_0x0: [0, Update DMA request disabled.]
      B_0x1: [1, Update DMA request enabled.]
  TIM6_SR:
    UIF:
      B_0x0: [0, No update occurred.]
      B_0x1: [1, "Update interrupt pending. This bit is set by hardware when the registers are updated:"]
  TIM6_EGR:
    UG:
      B_0x0: [0, No action.]
      B_0x1: [1, Re-initializes the timer counter and generates an update of the registers. Note that the prescaler counter is cleared too (but the prescaler ratio is not affected).]
TIM7:
  TIM7_CR1:
    CEN:
      B_0x0: [0, Counter disabled]
      B_0x1: [1, Counter enabled]
    UDIS:
      B_0x0: [0, "UEV enabled. The Update (UEV) event is generated by one of the following events:"]
      B_0x1: [1, "UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller."]
    URS:
      B_0x0: [0, "Any of the following events generates an update interrupt or DMA request if enabled. These events can be:"]
      B_0x1: [1, Only counter overflow/underflow generates an update interrupt or DMA request if enabled.]
    OPM:
      B_0x0: [0, Counter is not stopped at update event]
      B_0x1: [1, Counter stops counting at the next update event (clearing the CEN bit).]
    ARPE:
      B_0x0: [0, TIMx_ARR register is not buffered.]
      B_0x1: [1, TIMx_ARR register is buffered.]
    UIFREMAP:
      B_0x0: [0, No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.]
      B_0x1: [1, Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.]
  TIM7_CR2:
    MMS:
      B_0x0: [0, Reset - the UG bit from the TIMx_EGR register is used as a trigger output (TRGO). If reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.]
      B_0x1: [1, "Enable - the Counter enable signal, CNT_EN, is used as a trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode."]
      B_0x2: [2, Update - The update event is selected as a trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.]
  TIM7_DIER:
    UIE:
      B_0x0: [0, Update interrupt disabled.]
      B_0x1: [1, Update interrupt enabled.]
    UDE:
      B_0x0: [0, Update DMA request disabled.]
      B_0x1: [1, Update DMA request enabled.]
  TIM7_SR:
    UIF:
      B_0x0: [0, No update occurred.]
      B_0x1: [1, "Update interrupt pending. This bit is set by hardware when the registers are updated:"]
  TIM7_EGR:
    UG:
      B_0x0: [0, No action.]
      B_0x1: [1, Re-initializes the timer counter and generates an update of the registers. Note that the prescaler counter is cleared too (but the prescaler ratio is not affected).]
TIM8:
  TIM8_CR1:
    CEN:
      B_0x0: [0, Counter disabled]
      B_0x1: [1, Counter enabled]
    UDIS:
      B_0x0: [0, "UEV enabled. The Update (UEV) event is generated by one of the following events:"]
      B_0x1: [1, "UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller."]
    URS:
      B_0x0: [0, "Any of the following events generate an update interrupt or DMA request if enabled. These events can be:"]
      B_0x1: [1, Only counter overflow/underflow generates an update interrupt or DMA request if enabled.]
    OPM:
      B_0x0: [0, Counter is not stopped at update event]
      B_0x1: [1, Counter stops counting at the next update event (clearing the bit CEN)]
    DIR:
      B_0x0: [0, Counter used as upcounter]
      B_0x1: [1, Counter used as downcounter]
    CMS:
      B_0x0: [0, Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).]
      B_0x1: [1, Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting down.]
      B_0x2: [2, Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting up.]
      B_0x3: [3, Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set both when the counter is counting up or down.]
    ARPE:
      B_0x0: [0, TIMx_ARR register is not buffered]
      B_0x1: [1, TIMx_ARR register is buffered]
    CKD:
      B_0x0: [0, t<sub>DTS</sub>=t<sub>CK_INT</sub>]
      B_0x1: [1, t<sub>DTS</sub>=2*t<sub>CK_INT</sub>]
      B_0x2: [2, t<sub>DTS</sub>=4*t<sub>CK_INT</sub>]
      B_0x3: [3, "Reserved, do not program this value"]
    UIFREMAP:
      B_0x0: [0, No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.]
      B_0x1: [1, Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.]
  TIM8_CR2:
    CCPC:
      B_0x0: [0, "CCxE, CCxNE and OCxM bits are not preloaded"]
      B_0x1: [1, "CCxE, CCxNE and OCxM bits are preloaded, after having been written, they are updated only when a commutation event (COM) occurs (COMG bit set or rising edge detected on TRGI, depending on the CCUS bit)."]
    CCUS:
      B_0x0: [0, "When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit only"]
      B_0x1: [1, "When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit or when an rising edge occurs on TRGI"]
    CCDS:
      B_0x0: [0, CCx DMA request sent when CCx event occurs]
      B_0x1: [1, CCx DMA requests sent when update event occurs]
    MMS:
      B_0x0: [0, Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.]
      B_0x1: [1, "Enable - the Counter Enable signal CNT_EN is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enable. The Counter Enable signal is generated by a logic AND between CEN control bit and the trigger input when configured in gated mode. When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR register)."]
      B_0x2: [2, Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.]
      B_0x3: [3, "Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO)."]
      B_0x4: [4, Compare - OC1REFC signal is used as trigger output (TRGO)]
      B_0x5: [5, Compare - OC2REFC signal is used as trigger output (TRGO)]
      B_0x6: [6, Compare - OC3REFC signal is used as trigger output (TRGO)]
      B_0x7: [7, Compare - OC4REFC signal is used as trigger output (TRGO)]
    TI1S:
      B_0x0: [0, The TIMx_CH1 pin is connected to TI1 input]
      B_0x1: [1, "The TIMx_CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination)"]
    OIS1:
      B_0x0: [0, OC1=0 (after a dead-time if OC1N is implemented) when MOE=0]
      B_0x1: [1, OC1=1 (after a dead-time if OC1N is implemented) when MOE=0]
    OIS1N:
      B_0x0: [0, OC1N=0 after a dead-time when MOE=0]
      B_0x1: [1, OC1N=1 after a dead-time when MOE=0]
    MMS2:
      B_0x0: [0, "Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO2). If the reset is generated by the trigger input (slave mode controller configured in reset mode), the signal on TRGO2 is delayed compared to the actual reset."]
      B_0x1: [1, "Enable - the Counter Enable signal CNT_EN is used as trigger output (TRGO2). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic AND between the CEN control bit and the trigger input when configured in Gated mode. When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO2, except if the Master/Slave mode is selected (see the MSM bit description in TIMx_SMCR register)."]
      B_0x2: [2, "Update - the update event is selected as trigger output (TRGO2). For instance, a master timer can then be used as a prescaler for a slave timer."]
      B_0x3: [3, "Compare pulse - the trigger output sends a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or compare match occurs (TRGO2)."]
      B_0x4: [4, Compare - OC1REFC signal is used as trigger output (TRGO2)]
      B_0x5: [5, Compare - OC2REFC signal is used as trigger output (TRGO2)]
      B_0x6: [6, Compare - OC3REFC signal is used as trigger output (TRGO2)]
      B_0x7: [7, Compare - OC4REFC signal is used as trigger output (TRGO2)]
      B_0x8: [8, Compare - OC5REFC signal is used as trigger output (TRGO2)]
      B_0x9: [9, Compare - OC6REFC signal is used as trigger output (TRGO2)]
      B_0xA: [10, Compare Pulse - OC4REFC rising or falling edges generate pulses on TRGO2]
      B_0xB: [11, Compare Pulse - OC6REFC rising or falling edges generate pulses on TRGO2]
      B_0xC: [12, Compare Pulse - OC4REFC or OC6REFC rising edges generate pulses on TRGO2]
      B_0xD: [13, Compare Pulse - OC4REFC rising or OC6REFC falling edges generate pulses on TRGO2]
      B_0xE: [14, Compare Pulse - OC5REFC or OC6REFC rising edges generate pulses on TRGO2]
      B_0xF: [15, Compare Pulse - OC5REFC rising or OC6REFC falling edges generate pulses on TRGO2]
  TIM8_SMCR:
    SMS:
      B_0x0: [0, Slave mode disabled - if CEN =  1  then the prescaler is clocked directly by the internal clock.]
      B_0x1: [1, Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.]
      B_0x2: [2, Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.]
      B_0x3: [3, Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.]
      B_0x4: [4, Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.]
      B_0x5: [5, Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.]
      B_0x6: [6, Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.]
      B_0x7: [7, External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.]
    TS:
      B_0x0: [0, Internal Trigger 0 (ITR0)]
      B_0x1: [1, Internal Trigger 1 (ITR1)]
      B_0x2: [2, Internal Trigger 2 (ITR2)]
      B_0x3: [3, Internal Trigger 3 (ITR3)]
      B_0x4: [4, TI1 Edge Detector (TI1F_ED)]
      B_0x5: [5, Filtered Timer Input 1 (TI1FP1)]
      B_0x6: [6, Filtered Timer Input 2 (TI2FP2)]
      B_0x7: [7, External Trigger input (ETRF)]
    MSM:
      B_0x0: [0, No action]
      B_0x1: [1, The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.]
    ETF:
      B_0x0: [0, "No filter, sampling is done at f<sub>DTS</sub>"]
      B_0x1: [1, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=2"]
      B_0x2: [2, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=4"]
      B_0x3: [3, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=8"]
      B_0x4: [4, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=6"]
      B_0x5: [5, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=8"]
      B_0x6: [6, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=6"]
      B_0x7: [7, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=8"]
      B_0x8: [8, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=6"]
      B_0x9: [9, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=8"]
      B_0xA: [10, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=5"]
      B_0xB: [11, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=6"]
      B_0xC: [12, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=8"]
      B_0xD: [13, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=5"]
      B_0xE: [14, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=6"]
      B_0xF: [15, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=8"]
    ETPS:
      B_0x0: [0, Prescaler OFF]
      B_0x1: [1, ETRP frequency divided by 2]
      B_0x2: [2, ETRP frequency divided by 4]
      B_0x3: [3, ETRP frequency divided by 8]
    ECE:
      B_0x0: [0, External clock mode 2 disabled]
      B_0x1: [1, External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.]
    ETP:
      B_0x0: [0, "ETR is non-inverted, active at high level or rising edge."]
      B_0x1: [1, "ETR is inverted, active at low level or falling edge."]
  TIM8_DIER:
    UIE:
      B_0x0: [0, Update interrupt disabled]
      B_0x1: [1, Update interrupt enabled]
    CC1IE:
      B_0x0: [0, CC1 interrupt disabled]
      B_0x1: [1, CC1 interrupt enabled]
    CC2IE:
      B_0x0: [0, CC2 interrupt disabled]
      B_0x1: [1, CC2 interrupt enabled]
    CC3IE:
      B_0x0: [0, CC3 interrupt disabled]
      B_0x1: [1, CC3 interrupt enabled]
    CC4IE:
      B_0x0: [0, CC4 interrupt disabled]
      B_0x1: [1, CC4 interrupt enabled]
    COMIE:
      B_0x0: [0, COM interrupt disabled]
      B_0x1: [1, COM interrupt enabled]
    TIE:
      B_0x0: [0, Trigger interrupt disabled]
      B_0x1: [1, Trigger interrupt enabled]
    BIE:
      B_0x0: [0, Break interrupt disabled]
      B_0x1: [1, Break interrupt enabled]
    UDE:
      B_0x0: [0, Update DMA request disabled]
      B_0x1: [1, Update DMA request enabled]
    CC1DE:
      B_0x0: [0, CC1 DMA request disabled]
      B_0x1: [1, CC1 DMA request enabled]
    CC2DE:
      B_0x0: [0, CC2 DMA request disabled]
      B_0x1: [1, CC2 DMA request enabled]
    CC3DE:
      B_0x0: [0, CC3 DMA request disabled]
      B_0x1: [1, CC3 DMA request enabled]
    CC4DE:
      B_0x0: [0, CC4 DMA request disabled]
      B_0x1: [1, CC4 DMA request enabled]
    COMDE:
      B_0x0: [0, COM DMA request disabled]
      B_0x1: [1, COM DMA request enabled]
    TDE:
      B_0x0: [0, Trigger DMA request disabled]
      B_0x1: [1, Trigger DMA request enabled]
  TIM8_SR:
    UIF:
      B_0x0: [0, No update occurred.]
      B_0x1: [1, "Update interrupt pending. This bit is set by hardware when the registers are updated:"]
    CC1IF:
      B_0x0: [0, No compare match / No input capture occurred]
      B_0x1: [1, A compare match or an input capture occurred.]
    COMIF:
      B_0x0: [0, No COM event occurred.]
      B_0x1: [1, COM interrupt pending.]
    TIF:
      B_0x0: [0, No trigger event occurred.]
      B_0x1: [1, Trigger interrupt pending.]
    BIF:
      B_0x0: [0, No break event occurred.]
      B_0x1: [1, An active level has been detected on the break input. An interrupt is generated if BIE=1 in the TIMx_DIER register.]
    B2IF:
      B_0x0: [0, No break event occurred.]
      B_0x1: [1, An active level has been detected on the break 2 input. An interrupt is generated if BIE=1 in the TIMx_DIER register.]
    CC1OF:
      B_0x0: [0, No overcapture has been detected.]
      B_0x1: [1, The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set]
    SBIF:
      B_0x0: [0, No break event occurred.]
      B_0x1: [1, An active level has been detected on the system break input. An interrupt is generated if BIE=1 in the TIMx_DIER register.]
  TIM8_EGR:
    UG:
      B_0x0: [0, No action]
      B_0x1: [1, "Reinitialize the counter and generates an update of the registers. The prescaler internal counter is also cleared (the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (TIMx_ARR) if DIR=1 (downcounting)."]
    CC1G:
      B_0x0: [0, No action]
      B_0x1: [1, "A capture/compare event is generated on channel 1:"]
    COMG:
      B_0x0: [0, No action]
      B_0x1: [1, "When CCPC bit is set, it allows CCxE, CCxNE and OCxM bits to be updated."]
    TG:
      B_0x0: [0, No action]
      B_0x1: [1, The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.]
    BG:
      B_0x0: [0, No action]
      B_0x1: [1, A break event is generated. MOE bit is cleared and BIF flag is set. Related interrupt or DMA transfer can occur if enabled.]
    B2G:
      B_0x0: [0, No action]
      B_0x1: [1, A break 2 event is generated. MOE bit is cleared and B2IF flag is set. Related interrupt can occur if enabled.]
  TIM8_CCMR1:
    CC1S:
      B_0x0: [0, CC1 channel is configured as output]
      B_0x1: [1, "CC1 channel is configured as input, IC1 is mapped on TI1"]
      B_0x2: [2, "CC1 channel is configured as input, IC1 is mapped on TI2"]
      B_0x3: [3, "CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
    IC1PSC:
      B_0x0: [0, "no prescaler, capture is done each time an edge is detected on the capture input"]
      B_0x1: [1, capture is done once every 2 events]
      B_0x2: [2, capture is done once every 4 events]
      B_0x3: [3, capture is done once every 8 events]
    IC1F:
      B_0x0: [0, "No filter, sampling is done at f<sub>DTS</sub>"]
      B_0x1: [1, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=2"]
      B_0x2: [2, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=4"]
      B_0x3: [3, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=8"]
      B_0x4: [4, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=6"]
      B_0x5: [5, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=8"]
      B_0x6: [6, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=6"]
      B_0x7: [7, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=8"]
      B_0x8: [8, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=6"]
      B_0x9: [9, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=8"]
      B_0xA: [10, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=5"]
      B_0xB: [11, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=6"]
      B_0xC: [12, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=8"]
      B_0xD: [13, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=5"]
      B_0xE: [14, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=6"]
      B_0xF: [15, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=8"]
    CC2S:
      B_0x0: [0, CC2 channel is configured as output]
      B_0x1: [1, "CC2 channel is configured as input, IC2 is mapped on TI2"]
      B_0x2: [2, "CC2 channel is configured as input, IC2 is mapped on TI1"]
      B_0x3: [3, "CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
  TIM8_CCMR1_ALTERNATE:
    CC1S:
      B_0x0: [0, CC1 channel is configured as output]
      B_0x1: [1, "CC1 channel is configured as input, IC1 is mapped on TI1"]
      B_0x2: [2, "CC1 channel is configured as input, IC1 is mapped on TI2"]
      B_0x3: [3, "CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
    OC1FE:
      B_0x0: [0, CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.]
      B_0x1: [1, "An active edge on the trigger input acts like a compare match on CC1 output. Then, OC is set to the compare level independently from the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OCFE acts only if the channel is configured in PWM1 or PWM2 mode."]
    OC1PE:
      B_0x0: [0, "Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately."]
      B_0x1: [1, Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.]
    OC1M:
      B_0x0: [0, "Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.This mode can be used when the timer serves as a software timebase. When the frozen mode is enabled during timer operation, the output keeps the state (active or inactive) it had before entering the frozen state."]
      B_0x1: [1, Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).]
      B_0x2: [2, Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).]
      B_0x3: [3, Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.]
      B_0x4: [4, Force inactive level - OC1REF is forced low.]
      B_0x5: [5, Force active level - OC1REF is forced high.]
      B_0x6: [6, "PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT<TIMx_CCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF= 0 ) as long as TIMx_CNT>TIMx_CCR1 else active (OC1REF= 1 )."]
      B_0x7: [7, "PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT<TIMx_CCR1 else active. In downcounting, channel 1 is active as long as TIMx_CNT>TIMx_CCR1 else inactive."]
    OC1CE:
      B_0x0: [0, OC1Ref is not affected by the ETRF input]
      B_0x1: [1, OC1Ref is cleared as soon as a High level is detected on ETRF input]
    CC2S:
      B_0x0: [0, CC2 channel is configured as output]
      B_0x1: [1, "CC2 channel is configured as input, IC2 is mapped on TI2"]
      B_0x2: [2, "CC2 channel is configured as input, IC2 is mapped on TI1"]
      B_0x3: [3, "CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through the TS bit (TIMx_SMCR register)"]
  TIM8_CCMR2:
    CC3S:
      B_0x0: [0, CC3 channel is configured as output]
      B_0x1: [1, "CC3 channel is configured as input, IC3 is mapped on TI3"]
      B_0x2: [2, "CC3 channel is configured as input, IC3 is mapped on TI4"]
      B_0x3: [3, "CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
    CC4S:
      B_0x0: [0, CC4 channel is configured as output]
      B_0x1: [1, "CC4 channel is configured as input, IC4 is mapped on TI4"]
      B_0x2: [2, "CC4 channel is configured as input, IC4 is mapped on TI3"]
      B_0x3: [3, "CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
  TIM8_CCMR2_ALTERNATE:
    CC3S:
      B_0x0: [0, CC3 channel is configured as output]
      B_0x1: [1, "CC3 channel is configured as input, IC3 is mapped on TI3"]
      B_0x2: [2, "CC3 channel is configured as input, IC3 is mapped on TI4"]
      B_0x3: [3, "CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
    CC4S:
      B_0x0: [0, CC4 channel is configured as output]
      B_0x1: [1, "CC4 channel is configured as input, IC4 is mapped on TI4"]
      B_0x2: [2, "CC4 channel is configured as input, IC4 is mapped on TI3"]
      B_0x3: [3, "CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
  TIM8_CCER:
    CC1E:
      B_0x0: [0, Capture mode disabled / OC1 is not active (see below)]
      B_0x1: [1, Capture mode enabled / OC1 signal is output on the corresponding output pin]
    CC1P:
      B_0x0: [0, "OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)"]
      B_0x1: [1, "OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)"]
    CC1NE:
      B_0x0: [0, "Off - OC1N is not active. OC1N level is then function of MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits."]
      B_0x1: [1, "On - OC1N signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits."]
    CC1NP:
      B_0x0: [0, OC1N active high.]
      B_0x1: [1, OC1N active low.]
  TIM8_BDTR:
    LOCK:
      B_0x0: [0, LOCK OFF - No bit is write protected.]
      B_0x1: [1, "LOCK Level 1 = DTG bits in TIMx_BDTR register, OISx and OISxN bits in TIMx_CR2 register and BKE/BKP/AOE bits in TIMx_BDTR register can no longer be written."]
      B_0x2: [2, "LOCK Level 2 = LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in TIMx_CCER register, as long as the related channel is configured in output through the CCxS bits) as well as OSSR and OSSI bits can no longer be written."]
      B_0x3: [3, "LOCK Level 3 = LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in TIMx_CCMRx registers, as long as the related channel is configured in output through the CCxS bits) can no longer be written."]
    OSSI:
      B_0x0: [0, "When inactive, OC/OCN outputs are disabled (the timer releases the output control which is taken over by the GPIO logic and which imposes a Hi-Z state)."]
      B_0x1: [1, "When inactive, OC/OCN outputs are first forced with their inactive level then forced to their idle level after the deadtime. The timer maintains its control over the output."]
    OSSR:
      B_0x0: [0, "When inactive, OC/OCN outputs are disabled (the timer releases the output control which is taken over by the GPIO logic, which forces a Hi-Z state)."]
      B_0x1: [1, "When inactive, OC/OCN outputs are enabled with their inactive level as soon as CCxE=1 or CCxNE=1 (the output is still controlled by the timer)."]
    BKE:
      B_0x0: [0, Break function disabled]
      B_0x1: [1, Break function enabled]
    BKP:
      B_0x0: [0, Break input BRK is active low]
      B_0x1: [1, Break input BRK is active high]
    AOE:
      B_0x0: [0, MOE can be set only by software]
      B_0x1: [1, MOE can be set by software or automatically at the next update event (if none of the break inputs BRK and BRK2 is active)]
    MOE:
      B_0x0: [0, In response to a break 2 event. OC and OCN outputs are disabled]
      B_0x1: [1, "OC and OCN outputs are enabled if their respective enable bits are set (CCxE, CCxNE in TIMx_CCER register)."]
    BKF:
      B_0x0: [0, "No filter, BRK acts asynchronously"]
      B_0x1: [1, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=2"]
      B_0x2: [2, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=4"]
      B_0x3: [3, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=8"]
      B_0x4: [4, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=6"]
      B_0x5: [5, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=8"]
      B_0x6: [6, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=6"]
      B_0x7: [7, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=8"]
      B_0x8: [8, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=6"]
      B_0x9: [9, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=8"]
      B_0xA: [10, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=5"]
      B_0xB: [11, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=6"]
      B_0xC: [12, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=8"]
      B_0xD: [13, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=5"]
      B_0xE: [14, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=6"]
      B_0xF: [15, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=8"]
    BK2F:
      B_0x0: [0, "No filter, BRK2 acts asynchronously"]
      B_0x1: [1, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=2"]
      B_0x2: [2, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=4"]
      B_0x3: [3, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=8"]
      B_0x4: [4, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=6"]
      B_0x5: [5, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=8"]
      B_0x6: [6, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=6"]
      B_0x7: [7, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=8"]
      B_0x8: [8, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=6"]
      B_0x9: [9, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=8"]
      B_0xA: [10, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=5"]
      B_0xB: [11, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=6"]
      B_0xC: [12, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=8"]
      B_0xD: [13, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=5"]
      B_0xE: [14, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=6"]
      B_0xF: [15, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=8"]
    BK2E:
      B_0x0: [0, Break2 function disabled]
      B_0x1: [1, Break2 function enabled]
    BK2P:
      B_0x0: [0, Break input BRK2 is active low]
      B_0x1: [1, Break input BRK2 is active high]
  TIM8_DCR:
    DBA:
      B_0x0: [0, "TIMx_CR1,"]
      B_0x1: [1, "TIMx_CR2,"]
      B_0x2: [2, "TIMx_SMCR,"]
    DBL:
      B_0x0: [0, 1 transfer]
      B_0x1: [1, 2 transfers]
      B_0x2: [2, 3 transfers]
      B_0x11: [17, 18 transfers]
  TIM8_CCR5:
    GC5C1:
      B_0x0: [0, No effect of OC5REF on OC1REFC5]
      B_0x1: [1, OC1REFC is the logical AND of OC1REFC and OC5REF]
    GC5C2:
      B_0x0: [0, No effect of OC5REF on OC2REFC]
      B_0x1: [1, OC2REFC is the logical AND of OC2REFC and OC5REF]
    GC5C3:
      B_0x0: [0, No effect of OC5REF on OC3REFC]
      B_0x1: [1, OC3REFC is the logical AND of OC3REFC and OC5REF]
  TIM8_AF1:
    BKINE:
      B_0x0: [0, BKIN input disabled]
      B_0x1: [1, BKIN input enabled]
    BKCMP1E:
      B_0x0: [0, COMP1 input disabled]
      B_0x1: [1, COMP1 input enabled]
    BKCMP2E:
      B_0x0: [0, COMP2 input disabled]
      B_0x1: [1, COMP2 input enabled]
    BKDF1BK2E:
      B_0x0: [0, "dfsdm1_break[2] input disabled"]
      B_0x1: [1, "dfsdm1_break[2] input enabled"]
    BKINP:
      B_0x0: [0, "BKIN input polarity is not inverted (active low if BKP=0, active high if BKP=1)"]
      B_0x1: [1, "BKIN input polarity is inverted (active high if BKP=0, active low if BKP=1)"]
    BKCMP1P:
      B_0x0: [0, "COMP1 input polarity is not inverted (active low if BKP=0, active high if BKP=1)"]
      B_0x1: [1, "COMP1 input polarity is inverted (active high if BKP=0, active low if BKP=1)"]
    BKCMP2P:
      B_0x0: [0, "COMP2 input polarity is not inverted (active low if BKP=0, active high if BKP=1)"]
      B_0x1: [1, "COMP2 input polarity is inverted (active high if BKP=0, active low if BKP=1)"]
    ETRSEL:
      B_0x0: [0, ETR input is connected to I/O]
      B_0x1: [1, COMP1 output]
      B_0x2: [2, COMP2 output]
      B_0x3: [3, ADC2 AWD1]
      B_0x4: [4, ADC2 AWD2]
      B_0x5: [5, ADC2 AWD3]
      B_0x6: [6, ADC3 AWD1]
      B_0x7: [7, ADC3 AWD2]
      B_0x8: [8, ADC3 AWD3]
  TIM8_AF2:
    BK2INE:
      B_0x0: [0, BKIN2 input disabled]
      B_0x1: [1, BKIN2 input enabled]
    BK2CMP1E:
      B_0x0: [0, COMP1 input disabled]
      B_0x1: [1, COMP1 input enabled]
    BK2CMP2E:
      B_0x0: [0, COMP2 input disabled]
      B_0x1: [1, COMP2 input enabled]
    BK2DF1BK3E:
      B_0x0: [0, "dfsdm1_break[3] input disabled"]
      B_0x1: [1, "dfsdm1_break[3] input enabled"]
    BK2INP:
      B_0x0: [0, "BKIN2 input polarity is not inverted (active low if BK2P=0, active high if BK2P=1)"]
      B_0x1: [1, "BKIN2 input polarity is inverted (active high if BK2P=0, active low if BK2P=1)"]
    BK2CMP1P:
      B_0x0: [0, "COMP1 input polarity is not inverted (active low if BK2P=0, active high if BK2P=1)"]
      B_0x1: [1, "COMP1 input polarity is inverted (active high if BK2P=0, active low if BK2P=1)"]
    BK2CMP2P:
      B_0x0: [0, "COMP2 input polarity is not inverted (active low if BK2P=0, active high if BK2P=1)"]
      B_0x1: [1, "COMP2 input polarity is inverted (active high if BK2P=0, active low if BK2P=1)"]
  TIM8_TISEL:
    TI1SEL:
      B_0x0: [0, TIM8_CH1 input]
      B_0x1: [1, COMP2 output]
    TI2SEL:
      B_0x0: [0, TIM8_CH2 input]
    TI3SEL:
      B_0x0: [0, TIM8_CH3 input]
    TI4SEL:
      B_0x0: [0, TIM8_CH4 input]
TIM15:
  TIM15_CR1:
    CEN:
      B_0x0: [0, Counter disabled]
      B_0x1: [1, Counter enabled]
    UDIS:
      B_0x0: [0, "UEV enabled. The Update (UEV) event is generated by one of the following events:"]
      B_0x1: [1, "UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller."]
    URS:
      B_0x0: [0, "Any of the following events generate an update interrupt if enabled. These events can be:"]
      B_0x1: [1, Only counter overflow/underflow generates an update interrupt if enabled]
    OPM:
      B_0x0: [0, Counter is not stopped at update event]
      B_0x1: [1, Counter stops counting at the next update event (clearing the bit CEN)]
    ARPE:
      B_0x0: [0, TIMx_ARR register is not buffered]
      B_0x1: [1, TIMx_ARR register is buffered]
    CKD:
      B_0x0: [0, t<sub>DTS </sub>= t<sub>CK_INT</sub>]
      B_0x1: [1, t<sub>DTS</sub> = 2 * t<sub>CK_INT</sub>]
      B_0x2: [2, t<sub>DTS</sub> = 4 * t<sub>CK_INT</sub>]
      B_0x3: [3, "Reserved, do not program this value"]
    UIFREMAP:
      B_0x0: [0, No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.]
      B_0x1: [1, Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.]
  TIM15_CR2:
    CCPC:
      B_0x0: [0, "CCxE, CCxNE and OCxM bits are not preloaded"]
      B_0x1: [1, "CCxE, CCxNE and OCxM bits are preloaded, after having been written, they are updated only when a commutation event (COM) occurs (COMG bit set or rising edge detected on TRGI, depending on the CCUS bit)."]
    CCUS:
      B_0x0: [0, "When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit only."]
      B_0x1: [1, "When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit or when an rising edge occurs on TRGI."]
    CCDS:
      B_0x0: [0, CCx DMA request sent when CCx event occurs]
      B_0x1: [1, CCx DMA requests sent when update event occurs]
    MMS:
      B_0x0: [0, Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.]
      B_0x1: [1, "Enable - the Counter Enable signal CNT_EN is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enable. The Counter Enable signal is generated by a logic AND between CEN control bit and the trigger input when configured in gated mode. When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR register)."]
      B_0x2: [2, Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.]
      B_0x3: [3, "Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO)."]
      B_0x4: [4, Compare - OC1REFC signal is used as trigger output (TRGO).]
      B_0x5: [5, Compare - OC2REFC signal is used as trigger output (TRGO).]
    TI1S:
      B_0x0: [0, The TIMx_CH1 pin is connected to TI1 input]
      B_0x1: [1, "The TIMx_CH1, CH2 pins are connected to the TI1 input (XOR combination)"]
    OIS1:
      B_0x0: [0, OC1=0 (after a dead-time if OC1N is implemented) when MOE=0]
      B_0x1: [1, OC1=1 (after a dead-time if OC1N is implemented) when MOE=0]
    OIS1N:
      B_0x0: [0, OC1N=0 after a dead-time when MOE=0]
      B_0x1: [1, OC1N=1 after a dead-time when MOE=0]
    OIS2:
      B_0x0: [0, OC2=0 when MOE=0]
      B_0x1: [1, OC2=1 when MOE=0]
  TIM15_SMCR:
    SMS:
      B_0x0: [0, Slave mode disabled - if CEN =  1  then the prescaler is clocked directly by the internal clock.]
      B_0x4: [4, Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.]
      B_0x5: [5, Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.]
      B_0x6: [6, Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.]
      B_0x7: [7, External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.]
    TS:
      B_0x0: [0, Internal Trigger 0 (ITR0)]
      B_0x1: [1, Internal Trigger 1 (ITR1)]
      B_0x2: [2, Internal Trigger 2 (ITR2)]
      B_0x3: [3, Internal Trigger 3 (ITR3)]
      B_0x4: [4, TI1 Edge Detector (TI1F_ED)]
      B_0x5: [5, Filtered Timer Input 1 (TI1FP1)]
      B_0x6: [6, Filtered Timer Input 2 (TI2FP2)]
    MSM:
      B_0x0: [0, No action]
      B_0x1: [1, The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.]
  TIM15_DIER:
    UIE:
      B_0x0: [0, Update interrupt disabled]
      B_0x1: [1, Update interrupt enabled]
    CC1IE:
      B_0x0: [0, CC1 interrupt disabled]
      B_0x1: [1, CC1 interrupt enabled]
    CC2IE:
      B_0x0: [0, CC2 interrupt disabled]
      B_0x1: [1, CC2 interrupt enabled]
    COMIE:
      B_0x0: [0, COM interrupt disabled]
      B_0x1: [1, COM interrupt enabled]
    TIE:
      B_0x0: [0, Trigger interrupt disabled]
      B_0x1: [1, Trigger interrupt enabled]
    BIE:
      B_0x0: [0, Break interrupt disabled]
      B_0x1: [1, Break interrupt enabled]
    UDE:
      B_0x0: [0, Update DMA request disabled]
      B_0x1: [1, Update DMA request enabled]
    CC1DE:
      B_0x0: [0, CC1 DMA request disabled]
      B_0x1: [1, CC1 DMA request enabled]
    COMDE:
      B_0x0: [0, COM DMA request disabled]
      B_0x1: [1, COM DMA request enabled]
    TDE:
      B_0x0: [0, Trigger DMA request disabled]
      B_0x1: [1, Trigger DMA request enabled]
  TIM15_SR:
    UIF:
      B_0x0: [0, No update occurred.]
      B_0x1: [1, "Update interrupt pending. This bit is set by hardware when the registers are updated:"]
    CC1IF:
      B_0x0: [0, No compare match / No input capture occurred]
      B_0x1: [1, A compare match or an input capture occurred]
    COMIF:
      B_0x0: [0, No COM event occurred]
      B_0x1: [1, COM interrupt pending]
    TIF:
      B_0x0: [0, No trigger event occurred]
      B_0x1: [1, Trigger interrupt pending]
    BIF:
      B_0x0: [0, No break event occurred]
      B_0x1: [1, An active level has been detected on the break input]
    CC1OF:
      B_0x0: [0, No overcapture has been detected]
      B_0x1: [1, The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set]
  TIM15_EGR:
    UG:
      B_0x0: [0, No action]
      B_0x1: [1, Reinitialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected).]
    CC1G:
      B_0x0: [0, No action]
      B_0x1: [1, "A capture/compare event is generated on channel 1:"]
    COMG:
      B_0x0: [0, No action]
      B_0x1: [1, "When the CCPC bit is set, it is possible to update the CCxE, CCxNE and OCxM bits"]
    TG:
      B_0x0: [0, No action]
      B_0x1: [1, The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled]
    BG:
      B_0x0: [0, No action]
      B_0x1: [1, A break event is generated. MOE bit is cleared and BIF flag is set. Related interrupt or DMA transfer can occur if enabled.]
  TIM15_CCMR1:
    CC1S:
      B_0x0: [0, CC1 channel is configured as output]
      B_0x1: [1, "CC1 channel is configured as input, IC1 is mapped on TI1"]
      B_0x2: [2, "CC1 channel is configured as input, IC1 is mapped on TI2"]
      B_0x3: [3, "CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
    IC1PSC:
      B_0x0: [0, "no prescaler, capture is done each time an edge is detected on the capture input"]
      B_0x1: [1, capture is done once every 2 events]
      B_0x2: [2, capture is done once every 4 events]
      B_0x3: [3, capture is done once every 8 events]
    IC1F:
      B_0x0: [0, "No filter, sampling is done at f<sub>DTS</sub>"]
      B_0x1: [1, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=2"]
      B_0x2: [2, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=4"]
      B_0x3: [3, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=8"]
      B_0x4: [4, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=6"]
      B_0x5: [5, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=8"]
      B_0x6: [6, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=6"]
      B_0x7: [7, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=8"]
      B_0x8: [8, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=6"]
      B_0x9: [9, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=8"]
      B_0xA: [10, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=5"]
      B_0xB: [11, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=6"]
      B_0xC: [12, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=8"]
      B_0xD: [13, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=5"]
      B_0xE: [14, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=6"]
      B_0xF: [15, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=8"]
    CC2S:
      B_0x0: [0, CC2 channel is configured as output]
      B_0x1: [1, "CC2 channel is configured as input, IC2 is mapped on TI2"]
      B_0x2: [2, "CC2 channel is configured as input, IC2 is mapped on TI1"]
      B_0x3: [3, "CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
  TIM15_CCMR1_ALTERNATE:
    CC1S:
      B_0x0: [0, CC1 channel is configured as output.]
      B_0x1: [1, "CC1 channel is configured as input, IC1 is mapped on TI1."]
      B_0x2: [2, "CC1 channel is configured as input, IC1 is mapped on TI2."]
      B_0x3: [3, "CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)"]
    OC1FE:
      B_0x0: [0, CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.]
      B_0x1: [1, "An active edge on the trigger input acts like a compare match on CC1 output. Then, OC is set to the compare level independently of the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OCFE acts only if the channel is configured in PWM1 or PWM2 mode."]
    OC1PE:
      B_0x0: [0, "Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately."]
      B_0x1: [1, Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.]
    OC1M:
      B_0x0: [0, Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.]
      B_0x1: [1, Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).]
      B_0x2: [2, Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).]
      B_0x3: [3, Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.]
      B_0x4: [4, Force inactive level - OC1REF is forced low.]
      B_0x5: [5, Force active level - OC1REF is forced high.]
      B_0x6: [6, PWM mode 1 - Channel 1 is active as long as TIMx_CNT<TIMx_CCR1 else inactive.]
      B_0x7: [7, PWM mode 2 - Channel 1 is inactive as long as TIMx_CNT<TIMx_CCR1 else active.]
    CC2S:
      B_0x0: [0, CC2 channel is configured as output.]
      B_0x1: [1, "CC2 channel is configured as input, IC2 is mapped on TI2."]
      B_0x2: [2, "CC2 channel is configured as input, IC2 is mapped on TI1."]
      B_0x3: [3, "CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through the TS bit (TIMx_SMCR register)"]
  TIM15_CCER:
    CC1E:
      B_0x0: [0, Capture mode disabled / OC1 is not active (see below)]
      B_0x1: [1, Capture mode enabled / OC1 signal is output on the corresponding output pin]
    CC1P:
      B_0x0: [0, "OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)"]
      B_0x1: [1, "OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)"]
    CC1NE:
      B_0x0: [0, "Off - OC1N is not active. OC1N level is then function of MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits."]
      B_0x1: [1, "On - OC1N signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits."]
    CC1NP:
      B_0x0: [0, OC1N active high]
      B_0x1: [1, OC1N active low]
  TIM15_BDTR:
    LOCK:
      B_0x0: [0, LOCK OFF - No bit is write protected]
      B_0x1: [1, "LOCK Level 1 = DTG bits in TIMx_BDTR register, OISx and OISxN bits in TIMx_CR2 register and BKE/BKP/AOE bits in TIMx_BDTR register can no longer be written"]
      B_0x2: [2, "LOCK Level 2 = LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in TIMx_CCER register, as long as the related channel is configured in output through the CCxS bits) as well as OSSR and OSSI bits can no longer be written."]
      B_0x3: [3, "LOCK Level 3 = LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in TIMx_CCMRx registers, as long as the related channel is configured in output through the CCxS bits) can no longer be written."]
    OSSI:
      B_0x0: [0, "When inactive, OC/OCN outputs are disabled (OC/OCN enable output signal=0)"]
      B_0x1: [1, "When inactive, OC/OCN outputs are forced first with their idle level as soon as CCxE=1 or CCxNE=1. OC/OCN enable output signal=1)"]
    OSSR:
      B_0x0: [0, "When inactive, OC/OCN outputs are disabled (the timer releases the output control which is taken over by the GPIO, which forces a Hi-Z state)"]
      B_0x1: [1, "When inactive, OC/OCN outputs are enabled with their inactive level as soon as CCxE=1 or CCxNE=1 (the output is still controlled by the timer)."]
    BKE:
      B_0x0: [0, Break inputs (BRK and CCS clock failure event) disabled]
    BKP:
      B_0x0: [0, Break input BRK is active low]
      B_0x1: [1, Break input BRK is active high]
    AOE:
      B_0x0: [0, MOE can be set only by software]
      B_0x1: [1, MOE can be set by software or automatically at the next update event (if the break input is not be active)]
    MOE:
      B_0x0: [0, OC and OCN outputs are disabled or forced to idle state depending on the OSSI bit.]
      B_0x1: [1, "OC and OCN outputs are enabled if their respective enable bits are set (CCxE, CCxNE in TIMx_CCER register)"]
    BKF:
      B_0x0: [0, "No filter, BRK acts asynchronously"]
      B_0x1: [1, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=2"]
      B_0x2: [2, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=4"]
      B_0x3: [3, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=8"]
      B_0x4: [4, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=6"]
      B_0x5: [5, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=8"]
      B_0x6: [6, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=6"]
      B_0x7: [7, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=8"]
      B_0x8: [8, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=6"]
      B_0x9: [9, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=8"]
      B_0xA: [10, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=5"]
      B_0xB: [11, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=6"]
      B_0xC: [12, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=8"]
      B_0xD: [13, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=5"]
      B_0xE: [14, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=6"]
      B_0xF: [15, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=8"]
  TIM15_DCR:
    DBA:
      B_0x0: [0, "TIMx_CR1,"]
      B_0x1: [1, "TIMx_CR2,"]
      B_0x2: [2, "TIMx_SMCR,"]
    DBL:
      B_0x0: [0, "1 transfer,"]
      B_0x1: [1, "2 transfers,"]
      B_0x2: [2, "3 transfers,"]
      B_0x11: [17, 18 transfers.]
  TIM15_AF1:
    BKINE:
      B_0x0: [0, BKIN input disabled]
      B_0x1: [1, BKIN input enabled]
    BKCMP1E:
      B_0x0: [0, COMP1 input disabled]
      B_0x1: [1, COMP1 input enabled]
    BKCMP2E:
      B_0x0: [0, COMP2 input disabled]
      B_0x1: [1, COMP2 input enabled]
    BKDF1BK0E:
      B_0x0: [0, "dfsdm1_break[0]input disabled"]
      B_0x1: [1, "dfsdm1_break[0]input enabled"]
    BKINP:
      B_0x0: [0, BKIN input is active low]
      B_0x1: [1, BKIN input is active high]
    BKCMP1P:
      B_0x0: [0, COMP1 input is active low]
      B_0x1: [1, COMP1 input is active high]
    BKCMP2P:
      B_0x0: [0, COMP2 input is active low]
      B_0x1: [1, COMP2 input is active high]
  TIM15_TISEL:
    TI1SEL:
      B_0x0: [0, TIM15_CH1 input]
      B_0x1: [1, TIM2_CH1 input]
      B_0x2: [2, TIM3_CH1 input]
      B_0x3: [3, TIM4_CH1 input]
      B_0x4: [4, LSE]
      B_0x5: [5, CSI]
      B_0x6: [6, MCO2]
    TI2SEL:
      B_0x0: [0, TIM15_CH2 input]
      B_0x1: [1, TIM2_CH2 input]
      B_0x2: [2, TIM3_CH2 input]
      B_0x3: [3, TIM4_CH2 input]
TIM16:
  TIM16_CR1:
    CEN:
      B_0x0: [0, Counter disabled]
      B_0x1: [1, Counter enabled]
    UDIS:
      B_0x0: [0, "UEV enabled. The Update (UEV) event is generated by one of the following events:"]
      B_0x1: [1, "UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller."]
    URS:
      B_0x0: [0, "Any of the following events generate an update interrupt or DMA request if enabled. These events can be:"]
      B_0x1: [1, Only counter overflow/underflow generates an update interrupt or DMA request if enabled.]
    OPM:
      B_0x0: [0, Counter is not stopped at update event]
      B_0x1: [1, Counter stops counting at the next update event (clearing the bit CEN)]
    ARPE:
      B_0x0: [0, TIMx_ARR register is not buffered]
      B_0x1: [1, TIMx_ARR register is buffered]
    CKD:
      B_0x0: [0, t <sub>DTS</sub>= t<sub>CK_INT</sub>]
      B_0x1: [1, t <sub>DTS</sub>= 2 * t<sub>CK_INT</sub>]
      B_0x2: [2, t<sub>DTS</sub> = 4 * t<sub>CK_INT</sub>]
      B_0x3: [3, "Reserved, do not program this value"]
    UIFREMAP:
      B_0x0: [0, No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.]
      B_0x1: [1, Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.]
  TIM16_CR2:
    CCPC:
      B_0x0: [0, "CCxE, CCxNE and OCxM bits are not preloaded"]
      B_0x1: [1, "CCxE, CCxNE and OCxM bits are preloaded, after having been written, they are updated only when COM bit is set."]
    CCUS:
      B_0x0: [0, "When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit only."]
      B_0x1: [1, "When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit or when an rising edge occurs on TRGI."]
    CCDS:
      B_0x0: [0, CCx DMA request sent when CCx event occurs]
      B_0x1: [1, CCx DMA requests sent when update event occurs]
    OIS1:
      B_0x0: [0, OC1=0 (after a dead-time if OC1N is implemented) when MOE=0]
      B_0x1: [1, OC1=1 (after a dead-time if OC1N is implemented) when MOE=0]
    OIS1N:
      B_0x0: [0, OC1N=0 after a dead-time when MOE=0]
      B_0x1: [1, OC1N=1 after a dead-time when MOE=0]
  TIM16_DIER:
    UIE:
      B_0x0: [0, Update interrupt disabled]
      B_0x1: [1, Update interrupt enabled]
    CC1IE:
      B_0x0: [0, CC1 interrupt disabled]
      B_0x1: [1, CC1 interrupt enabled]
    COMIE:
      B_0x0: [0, COM interrupt disabled]
      B_0x1: [1, COM interrupt enabled]
    BIE:
      B_0x0: [0, Break interrupt disabled]
      B_0x1: [1, Break interrupt enabled]
    UDE:
      B_0x0: [0, Update DMA request disabled]
      B_0x1: [1, Update DMA request enabled]
    CC1DE:
      B_0x0: [0, CC1 DMA request disabled]
      B_0x1: [1, CC1 DMA request enabled]
  TIM16_SR:
    UIF:
      B_0x0: [0, No update occurred.]
      B_0x1: [1, "Update interrupt pending. This bit is set by hardware when the registers are updated:"]
    CC1IF:
      B_0x0: [0, No compare match / No input capture occurred]
      B_0x1: [1, A compare match or an input capture occurred]
    COMIF:
      B_0x0: [0, No COM event occurred]
      B_0x1: [1, COM interrupt pending]
    BIF:
      B_0x0: [0, No break event occurred]
      B_0x1: [1, An active level has been detected on the break input]
    CC1OF:
      B_0x0: [0, No overcapture has been detected]
      B_0x1: [1, The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set]
  TIM16_EGR:
    UG:
      B_0x0: [0, No action.]
      B_0x1: [1, Reinitialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected).]
    CC1G:
      B_0x0: [0, No action.]
      B_0x1: [1, "A capture/compare event is generated on channel 1:"]
    COMG:
      B_0x0: [0, No action]
      B_0x1: [1, "When the CCPC bit is set, it is possible to update the CCxE, CCxNE and OCxM bits"]
    BG:
      B_0x0: [0, No action.]
      B_0x1: [1, A break event is generated. MOE bit is cleared and BIF flag is set. Related interrupt or DMA transfer can occur if enabled.]
  TIM16_CCMR1:
    CC1S:
      B_0x0: [0, CC1 channel is configured as output]
      B_0x1: [1, "CC1 channel is configured as input, IC1 is mapped on TI1"]
    IC1PSC:
      B_0x0: [0, "no prescaler, capture is done each time an edge is detected on the capture input."]
      B_0x1: [1, capture is done once every 2 events]
      B_0x2: [2, capture is done once every 4 events]
      B_0x3: [3, capture is done once every 8 events]
    IC1F:
      B_0x0: [0, "No filter, sampling is done at f<sub>DTS</sub>"]
      B_0x1: [1, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=2"]
      B_0x2: [2, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=4"]
      B_0x3: [3, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=8"]
      B_0x4: [4, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N="]
      B_0x5: [5, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=8"]
      B_0x6: [6, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=6"]
      B_0x7: [7, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=8"]
      B_0x8: [8, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=6"]
      B_0x9: [9, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=8"]
      B_0xA: [10, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=5"]
      B_0xB: [11, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=6"]
      B_0xC: [12, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=8"]
      B_0xD: [13, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=5"]
      B_0xE: [14, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=6"]
      B_0xF: [15, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=8"]
  TIM16_CCMR1_ALTERNATE:
    CC1S:
      B_0x0: [0, CC1 channel is configured as output]
      B_0x1: [1, "CC1 channel is configured as input, IC1 is mapped on TI1"]
    OC1FE:
      B_0x0: [0, CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.]
      B_0x1: [1, "An active edge on the trigger input acts like a compare match on CC1 output. Then, OC is set to the compare level independently of the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OC1FE acts only if the channel is configured in PWM1 or PWM2 mode."]
    OC1PE:
      B_0x0: [0, "Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately."]
      B_0x1: [1, Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.]
    OC1M:
      B_0x0: [0, "Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs. This mode can be used when the timer serves as a software timebase. When the frozen mode is enabled during timer operation, the output keeps the state (active or inactive) it had before entering the frozen state."]
      B_0x1: [1, Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).]
      B_0x2: [2, Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).]
      B_0x3: [3, Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.]
      B_0x4: [4, Force inactive level - OC1REF is forced low.]
      B_0x5: [5, Force active level - OC1REF is forced high.]
      B_0x6: [6, PWM mode 1 - Channel 1 is active as long as TIMx_CNT<TIMx_CCR1 else inactive.]
      B_0x7: [7, PWM mode 2 - Channel 1 is inactive as long as TIMx_CNT<TIMx_CCR1 else active.]
  TIM16_CCER:
    CC1E:
      B_0x0: [0, Capture mode disabled / OC1 is not active (see below)]
      B_0x1: [1, Capture mode enabled / OC1 signal is output on the corresponding output pin]
    CC1P:
      B_0x0: [0, "OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)"]
      B_0x1: [1, "OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)"]
    CC1NE:
      B_0x0: [0, "Off - OC1N is not active. OC1N level is then function of MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits."]
      B_0x1: [1, "On - OC1N signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits."]
    CC1NP:
      B_0x0: [0, OC1N active high]
      B_0x1: [1, OC1N active low]
  TIM16_BDTR:
    LOCK:
      B_0x0: [0, LOCK OFF - No bit is write protected]
      B_0x1: [1, "LOCK Level 1 = DTG bits in TIMx_BDTR register, OISx and OISxN bits in TIMx_CR2 register and BKE/BKP/AOE bits in TIMx_BDTR register can no longer be written."]
      B_0x2: [2, "LOCK Level 2 = LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in TIMx_CCER register, as long as the related channel is configured in output through the CCxS bits) as well as OSSR and OSSI bits can no longer be written."]
      B_0x3: [3, "LOCK Level 3 = LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in TIMx_CCMRx registers, as long as the related channel is configured in output through the CCxS bits) can no longer be written."]
    OSSI:
      B_0x0: [0, "When inactive, OC/OCN outputs are disabled (OC/OCN enable output signal=0)"]
      B_0x1: [1, "When inactive, OC/OCN outputs are forced first with their idle level as soon as CCxE=1 or CCxNE=1. OC/OCN enable output signal=1)"]
    OSSR:
      B_0x0: [0, "When inactive, OC/OCN outputs are disabled (the timer releases the output control which is taken over by the GPIO, which forces a Hi-Z state)"]
      B_0x1: [1, "When inactive, OC/OCN outputs are enabled with their inactive level as soon as CCxE=1 or CCxNE=1 (the output is still controlled by the timer)."]
    BKE:
      B_0x0: [0, Break inputs (BRK and CCS clock failure event) disabled]
    BKP:
      B_0x0: [0, Break input BRK is active low]
      B_0x1: [1, Break input BRK is active high]
    AOE:
      B_0x0: [0, MOE can be set only by software]
      B_0x1: [1, MOE can be set by software or automatically at the next update event (if the break input is not be active)]
    MOE:
      B_0x0: [0, OC and OCN outputs are disabled or forced to idle state depending on the OSSI bit.]
      B_0x1: [1, "OC and OCN outputs are enabled if their respective enable bits are set (CCxE, CCxNE in TIMx_CCER register)"]
    BKF:
      B_0x0: [0, "No filter, BRK acts asynchronously"]
      B_0x1: [1, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=2"]
      B_0x2: [2, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=4"]
      B_0x3: [3, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=8"]
      B_0x4: [4, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=6"]
      B_0x5: [5, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=8"]
      B_0x6: [6, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=6"]
      B_0x7: [7, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=8"]
      B_0x8: [8, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=6"]
      B_0x9: [9, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=8"]
      B_0xA: [10, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=5"]
      B_0xB: [11, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=6"]
      B_0xC: [12, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=8"]
      B_0xD: [13, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=5"]
      B_0xE: [14, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=6"]
      B_0xF: [15, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=8"]
  TIM16_DCR:
    DBA:
      B_0x0: [0, "TIMx_CR1,"]
      B_0x1: [1, "TIMx_CR2,"]
      B_0x2: [2, "TIMx_SMCR,"]
    DBL:
      B_0x0: [0, "1 transfer,"]
      B_0x1: [1, "2 transfers,"]
      B_0x2: [2, "3 transfers,"]
      B_0x11: [17, 18 transfers.]
  TIM16_AF1:
    BKINE:
      B_0x0: [0, BKIN input disabled]
      B_0x1: [1, BKIN input enabled]
    BKCMP1E:
      B_0x0: [0, COMP1 input disabled]
      B_0x1: [1, COMP1 input enabled]
    BKCMP2E:
      B_0x0: [0, COMP2 input disabled]
      B_0x1: [1, COMP2 input enabled]
    BKDF1BK1E:
      B_0x0: [0, "dfsdm1_break[1] input disabled"]
      B_0x1: [1, "dfsdm1_break[1] input enabled"]
    BKINP:
      B_0x0: [0, BKIN input is active low]
      B_0x1: [1, BKIN input is active high]
    BKCMP1P:
      B_0x0: [0, COMP1 input is active low]
      B_0x1: [1, COMP1 input is active high]
    BKCMP2P:
      B_0x0: [0, COMP2 input is active low]
      B_0x1: [1, COMP2 input is active high]
  TIM16_TISEL:
    TI1SEL:
      B_0x0: [0, TIM16_CH1 input]
      B_0x1: [1, LSI]
      B_0x2: [2, LSE]
      B_0x3: [3, WKUP_IT]
TIM17:
  TIM17_CR1:
    CEN:
      B_0x0: [0, Counter disabled]
      B_0x1: [1, Counter enabled]
    UDIS:
      B_0x0: [0, "UEV enabled. The Update (UEV) event is generated by one of the following events:"]
      B_0x1: [1, "UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller."]
    URS:
      B_0x0: [0, "Any of the following events generate an update interrupt or DMA request if enabled. These events can be:"]
      B_0x1: [1, Only counter overflow/underflow generates an update interrupt or DMA request if enabled.]
    OPM:
      B_0x0: [0, Counter is not stopped at update event]
      B_0x1: [1, Counter stops counting at the next update event (clearing the bit CEN)]
    ARPE:
      B_0x0: [0, TIMx_ARR register is not buffered]
      B_0x1: [1, TIMx_ARR register is buffered]
    CKD:
      B_0x0: [0, t <sub>DTS</sub>= t<sub>CK_INT</sub>]
      B_0x1: [1, t <sub>DTS</sub>= 2 * t<sub>CK_INT</sub>]
      B_0x2: [2, t<sub>DTS</sub> = 4 * t<sub>CK_INT</sub>]
      B_0x3: [3, "Reserved, do not program this value"]
    UIFREMAP:
      B_0x0: [0, No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.]
      B_0x1: [1, Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.]
  TIM17_CR2:
    CCPC:
      B_0x0: [0, "CCxE, CCxNE and OCxM bits are not preloaded"]
      B_0x1: [1, "CCxE, CCxNE and OCxM bits are preloaded, after having been written, they are updated only when COM bit is set."]
    CCUS:
      B_0x0: [0, "When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit only."]
      B_0x1: [1, "When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit or when an rising edge occurs on TRGI."]
    CCDS:
      B_0x0: [0, CCx DMA request sent when CCx event occurs]
      B_0x1: [1, CCx DMA requests sent when update event occurs]
    OIS1:
      B_0x0: [0, OC1=0 (after a dead-time if OC1N is implemented) when MOE=0]
      B_0x1: [1, OC1=1 (after a dead-time if OC1N is implemented) when MOE=0]
    OIS1N:
      B_0x0: [0, OC1N=0 after a dead-time when MOE=0]
      B_0x1: [1, OC1N=1 after a dead-time when MOE=0]
  TIM17_DIER:
    UIE:
      B_0x0: [0, Update interrupt disabled]
      B_0x1: [1, Update interrupt enabled]
    CC1IE:
      B_0x0: [0, CC1 interrupt disabled]
      B_0x1: [1, CC1 interrupt enabled]
    COMIE:
      B_0x0: [0, COM interrupt disabled]
      B_0x1: [1, COM interrupt enabled]
    BIE:
      B_0x0: [0, Break interrupt disabled]
      B_0x1: [1, Break interrupt enabled]
    UDE:
      B_0x0: [0, Update DMA request disabled]
      B_0x1: [1, Update DMA request enabled]
    CC1DE:
      B_0x0: [0, CC1 DMA request disabled]
      B_0x1: [1, CC1 DMA request enabled]
  TIM17_SR:
    UIF:
      B_0x0: [0, No update occurred.]
      B_0x1: [1, "Update interrupt pending. This bit is set by hardware when the registers are updated:"]
    CC1IF:
      B_0x0: [0, No compare match / No input capture occurred]
      B_0x1: [1, A compare match or an input capture occurred]
    COMIF:
      B_0x0: [0, No COM event occurred]
      B_0x1: [1, COM interrupt pending]
    BIF:
      B_0x0: [0, No break event occurred]
      B_0x1: [1, An active level has been detected on the break input]
    CC1OF:
      B_0x0: [0, No overcapture has been detected]
      B_0x1: [1, The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set]
  TIM17_EGR:
    UG:
      B_0x0: [0, No action.]
      B_0x1: [1, Reinitialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected).]
    CC1G:
      B_0x0: [0, No action.]
      B_0x1: [1, "A capture/compare event is generated on channel 1:"]
    COMG:
      B_0x0: [0, No action]
      B_0x1: [1, "When the CCPC bit is set, it is possible to update the CCxE, CCxNE and OCxM bits"]
    BG:
      B_0x0: [0, No action.]
      B_0x1: [1, A break event is generated. MOE bit is cleared and BIF flag is set. Related interrupt or DMA transfer can occur if enabled.]
  TIM17_CCMR1:
    CC1S:
      B_0x0: [0, CC1 channel is configured as output]
      B_0x1: [1, "CC1 channel is configured as input, IC1 is mapped on TI1"]
    IC1PSC:
      B_0x0: [0, "no prescaler, capture is done each time an edge is detected on the capture input."]
      B_0x1: [1, capture is done once every 2 events]
      B_0x2: [2, capture is done once every 4 events]
      B_0x3: [3, capture is done once every 8 events]
    IC1F:
      B_0x0: [0, "No filter, sampling is done at f<sub>DTS</sub>"]
      B_0x1: [1, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=2"]
      B_0x2: [2, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=4"]
      B_0x3: [3, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=8"]
      B_0x4: [4, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N="]
      B_0x5: [5, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=8"]
      B_0x6: [6, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=6"]
      B_0x7: [7, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=8"]
      B_0x8: [8, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=6"]
      B_0x9: [9, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=8"]
      B_0xA: [10, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=5"]
      B_0xB: [11, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=6"]
      B_0xC: [12, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=8"]
      B_0xD: [13, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=5"]
      B_0xE: [14, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=6"]
      B_0xF: [15, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=8"]
  TIM17_CCMR1_ALTERNATE:
    CC1S:
      B_0x0: [0, CC1 channel is configured as output]
      B_0x1: [1, "CC1 channel is configured as input, IC1 is mapped on TI1"]
    OC1FE:
      B_0x0: [0, CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.]
      B_0x1: [1, "An active edge on the trigger input acts like a compare match on CC1 output. Then, OC is set to the compare level independently of the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OC1FE acts only if the channel is configured in PWM1 or PWM2 mode."]
    OC1PE:
      B_0x0: [0, "Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately."]
      B_0x1: [1, Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.]
    OC1M:
      B_0x0: [0, "Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs. This mode can be used when the timer serves as a software timebase. When the frozen mode is enabled during timer operation, the output keeps the state (active or inactive) it had before entering the frozen state."]
      B_0x1: [1, Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).]
      B_0x2: [2, Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).]
      B_0x3: [3, Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.]
      B_0x4: [4, Force inactive level - OC1REF is forced low.]
      B_0x5: [5, Force active level - OC1REF is forced high.]
      B_0x6: [6, PWM mode 1 - Channel 1 is active as long as TIMx_CNT<TIMx_CCR1 else inactive.]
      B_0x7: [7, PWM mode 2 - Channel 1 is inactive as long as TIMx_CNT<TIMx_CCR1 else active.]
  TIM17_CCER:
    CC1E:
      B_0x0: [0, Capture mode disabled / OC1 is not active (see below)]
      B_0x1: [1, Capture mode enabled / OC1 signal is output on the corresponding output pin]
    CC1P:
      B_0x0: [0, "OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)"]
      B_0x1: [1, "OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)"]
    CC1NE:
      B_0x0: [0, "Off - OC1N is not active. OC1N level is then function of MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits."]
      B_0x1: [1, "On - OC1N signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits."]
    CC1NP:
      B_0x0: [0, OC1N active high]
      B_0x1: [1, OC1N active low]
  TIM17_BDTR:
    LOCK:
      B_0x0: [0, LOCK OFF - No bit is write protected]
      B_0x1: [1, "LOCK Level 1 = DTG bits in TIMx_BDTR register, OISx and OISxN bits in TIMx_CR2 register and BKE/BKP/AOE bits in TIMx_BDTR register can no longer be written."]
      B_0x2: [2, "LOCK Level 2 = LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in TIMx_CCER register, as long as the related channel is configured in output through the CCxS bits) as well as OSSR and OSSI bits can no longer be written."]
      B_0x3: [3, "LOCK Level 3 = LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in TIMx_CCMRx registers, as long as the related channel is configured in output through the CCxS bits) can no longer be written."]
    OSSI:
      B_0x0: [0, "When inactive, OC/OCN outputs are disabled (OC/OCN enable output signal=0)"]
      B_0x1: [1, "When inactive, OC/OCN outputs are forced first with their idle level as soon as CCxE=1 or CCxNE=1. OC/OCN enable output signal=1)"]
    OSSR:
      B_0x0: [0, "When inactive, OC/OCN outputs are disabled (the timer releases the output control which is taken over by the GPIO, which forces a Hi-Z state)"]
      B_0x1: [1, "When inactive, OC/OCN outputs are enabled with their inactive level as soon as CCxE=1 or CCxNE=1 (the output is still controlled by the timer)."]
    BKE:
      B_0x0: [0, Break inputs (BRK and CCS clock failure event) disabled]
    BKP:
      B_0x0: [0, Break input BRK is active low]
      B_0x1: [1, Break input BRK is active high]
    AOE:
      B_0x0: [0, MOE can be set only by software]
      B_0x1: [1, MOE can be set by software or automatically at the next update event (if the break input is not be active)]
    MOE:
      B_0x0: [0, OC and OCN outputs are disabled or forced to idle state depending on the OSSI bit.]
      B_0x1: [1, "OC and OCN outputs are enabled if their respective enable bits are set (CCxE, CCxNE in TIMx_CCER register)"]
    BKF:
      B_0x0: [0, "No filter, BRK acts asynchronously"]
      B_0x1: [1, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=2"]
      B_0x2: [2, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=4"]
      B_0x3: [3, "f<sub>SAMPLING</sub>=f<sub>CK_INT</sub>, N=8"]
      B_0x4: [4, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=6"]
      B_0x5: [5, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/2, N=8"]
      B_0x6: [6, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=6"]
      B_0x7: [7, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/4, N=8"]
      B_0x8: [8, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=6"]
      B_0x9: [9, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/8, N=8"]
      B_0xA: [10, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=5"]
      B_0xB: [11, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=6"]
      B_0xC: [12, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/16, N=8"]
      B_0xD: [13, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=5"]
      B_0xE: [14, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=6"]
      B_0xF: [15, "f<sub>SAMPLING</sub>=f<sub>DTS</sub>/32, N=8"]
  TIM17_DCR:
    DBA:
      B_0x0: [0, "TIMx_CR1,"]
      B_0x1: [1, "TIMx_CR2,"]
      B_0x2: [2, "TIMx_SMCR,"]
    DBL:
      B_0x0: [0, "1 transfer,"]
      B_0x1: [1, "2 transfers,"]
      B_0x2: [2, "3 transfers,"]
      B_0x11: [17, 18 transfers.]
  TIM17_AF1:
    BKINE:
      B_0x0: [0, BKIN input disabled]
      B_0x1: [1, BKIN input enabled]
    BKCMP1E:
      B_0x0: [0, COMP1 input disabled]
      B_0x1: [1, COMP1 input enabled]
    BKCMP2E:
      B_0x0: [0, COMP2 input disabled]
      B_0x1: [1, COMP2 input enabled]
    BKDF1BK2E:
      B_0x0: [0, "dfsdm1_break[2] input disabled"]
      B_0x1: [1, "dfsdm1_break[2] input enabled"]
    BKINP:
      B_0x0: [0, BKIN input is active low]
      B_0x1: [1, BKIN input is active high]
    BKCMP1P:
      B_0x0: [0, COMP1 input is active low]
      B_0x1: [1, COMP1 input is active high]
    BKCMP2P:
      B_0x0: [0, COMP2 input is active low]
      B_0x1: [1, COMP2 input is active high]
  TIM17_TISEL:
    TI1SEL:
      B_0x0: [0, TIM17_CH1 input]
      B_0x2: [2, HSE_1MHz]
      B_0x3: [3, MCO1]
USART1:
  USART_CR1:
    UE:
      B_0x0: [0, "USART prescaler and outputs disabled, low-power mode"]
      B_0x1: [1, USART enabled]
    UESM:
      B_0x0: [0, USART not able to wake up the MCU from low-power mode.]
      B_0x1: [1, USART able to wake up the MCU from low-power mode.]
    RE:
      B_0x0: [0, Receiver is disabled]
      B_0x1: [1, Receiver is enabled and begins searching for a start bit]
    TE:
      B_0x0: [0, Transmitter is disabled]
      B_0x1: [1, Transmitter is enabled]
    IDLEIE:
      B_0x0: [0, Interrupt inhibited]
      B_0x1: [1, USART interrupt generated whenever IDLE = 1 in the USART_ISR register]
    RXFNEIE:
      B_0x0: [0, Interrupt inhibited]
      B_0x1: [1, USART interrupt generated whenever ORE = 1 or RXFNE = 1 in the USART_ISR register]
    TCIE:
      B_0x0: [0, Interrupt inhibited]
      B_0x1: [1, USART interrupt generated whenever TC = 1 in the USART_ISR register]
    TXFNFIE:
      B_0x0: [0, Interrupt inhibited]
      B_0x1: [1, USART interrupt generated whenever TXFNF =1 in the USART_ISR register]
    PEIE:
      B_0x0: [0, Interrupt inhibited]
      B_0x1: [1, USART interrupt generated whenever PE = 1 in the USART_ISR register]
    PS:
      B_0x0: [0, Even parity]
      B_0x1: [1, Odd parity]
    PCE:
      B_0x0: [0, Parity control disabled]
      B_0x1: [1, Parity control enabled]
    WAKE:
      B_0x0: [0, Idle line]
      B_0x1: [1, Address mark]
    MME:
      B_0x0: [0, Receiver in active mode permanently]
      B_0x1: [1, Receiver can switch between Mute mode and active mode.]
    CMIE:
      B_0x0: [0, Interrupt inhibited]
      B_0x1: [1, USART interrupt generated when the CMF bit is set in the USART_ISR register.]
    OVER8:
      B_0x0: [0, Oversampling by 16]
      B_0x1: [1, Oversampling by 8]
    RTOIE:
      B_0x0: [0, Interrupt inhibited]
      B_0x1: [1, USART interrupt generated when the RTOF bit is set in the USART_ISR register.]
    EOBIE:
      B_0x0: [0, Interrupt inhibited]
      B_0x1: [1, USART interrupt generated when the EOBF flag is set in the USART_ISR register]
    FIFOEN:
      B_0x0: [0, FIFO mode is disabled.]
      B_0x1: [1, FIFO mode is enabled.]
    TXFEIE:
      B_0x0: [0, Interrupt inhibited]
      B_0x1: [1, USART interrupt generated when TXFE = 1 in the USART_ISR register]
    RXFFIE:
      B_0x0: [0, Interrupt inhibited]
      B_0x1: [1, USART interrupt generated when RXFF = 1 in the USART_ISR register]
  USART_CR1_ALTERNATE:
    UE:
      B_0x0: [0, "USART prescaler and outputs disabled, low-power mode"]
      B_0x1: [1, USART enabled]
    UESM:
      B_0x0: [0, USART not able to wake up the MCU from low-power mode.]
      B_0x1: [1, USART able to wake up the MCU from low-power mode.]
    RE:
      B_0x0: [0, Receiver is disabled]
      B_0x1: [1, Receiver is enabled and begins searching for a start bit]
    TE:
      B_0x0: [0, Transmitter is disabled]
      B_0x1: [1, Transmitter is enabled]
    IDLEIE:
      B_0x0: [0, Interrupt inhibited]
      B_0x1: [1, USART interrupt generated whenever IDLE = 1 in the USART_ISR register]
    RXNEIE:
      B_0x0: [0, Interrupt inhibited]
      B_0x1: [1, USART interrupt generated whenever ORE = 1 or RXNE = 1 in the USART_ISR register]
    TCIE:
      B_0x0: [0, Interrupt inhibited]
      B_0x1: [1, USART interrupt generated whenever TC = 1 in the USART_ISR register]
    TXEIE:
      B_0x0: [0, Interrupt inhibited]
      B_0x1: [1, USART interrupt generated whenever TXE =1 in the USART_ISR register]
    PEIE:
      B_0x0: [0, Interrupt inhibited]
      B_0x1: [1, USART interrupt generated whenever PE = 1 in the USART_ISR register]
    PS:
      B_0x0: [0, Even parity]
      B_0x1: [1, Odd parity]
    PCE:
      B_0x0: [0, Parity control disabled]
      B_0x1: [1, Parity control enabled]
    WAKE:
      B_0x0: [0, Idle line]
      B_0x1: [1, Address mark]
    MME:
      B_0x0: [0, Receiver in active mode permanently]
      B_0x1: [1, Receiver can switch between Mute mode and active mode.]
    CMIE:
      B_0x0: [0, Interrupt inhibited]
      B_0x1: [1, USART interrupt generated when the CMF bit is set in the USART_ISR register.]
    OVER8:
      B_0x0: [0, Oversampling by 16]
      B_0x1: [1, Oversampling by 8]
    RTOIE:
      B_0x0: [0, Interrupt inhibited]
      B_0x1: [1, USART interrupt generated when the RTOF bit is set in the USART_ISR register.]
    EOBIE:
      B_0x0: [0, Interrupt inhibited]
      B_0x1: [1, USART interrupt generated when the EOBF flag is set in the USART_ISR register]
    FIFOEN:
      B_0x0: [0, FIFO mode is disabled.]
      B_0x1: [1, FIFO mode is enabled.]
  USART_CR2:
    SLVEN:
      B_0x0: [0, Slave mode disabled.]
      B_0x1: [1, Slave mode enabled.]
    DIS_NSS:
      B_0x0: [0, SPI slave selection depends on NSS input pin.]
      B_0x1: [1, SPI slave is always selected and NSS input pin is ignored.]
    ADDM7:
      B_0x0: [0, 4-bit address detection]
      B_0x1: [1, 7-bit address detection (in 8-bit data mode)]
    LBDL:
      B_0x0: [0, 10-bit break detection]
      B_0x1: [1, 11-bit break detection]
    LBDIE:
      B_0x0: [0, Interrupt is inhibited]
      B_0x1: [1, An interrupt is generated whenever LBDF = 1 in the USART_ISR register]
    LBCL:
      B_0x0: [0, The clock pulse of the last data bit is not output to the CK pin]
      B_0x1: [1, The clock pulse of the last data bit is output to the CK pin]
    CPHA:
      B_0x0: [0, The first clock transition is the first data capture edge]
      B_0x1: [1, The second clock transition is the first data capture edge]
    CPOL:
      B_0x0: [0, Steady low value on CK pin outside transmission window]
      B_0x1: [1, Steady high value on CK pin outside transmission window]
    CLKEN:
      B_0x0: [0, CK pin disabled]
      B_0x1: [1, CK pin enabled]
    STOP:
      B_0x0: [0, 1 stop bit]
      B_0x1: [1, 0.5 stop bit.]
      B_0x2: [2, 2 stop bits]
      B_0x3: [3, 1.5 stop bits]
    LINEN:
      B_0x0: [0, LIN mode disabled]
      B_0x1: [1, LIN mode enabled]
    SWAP:
      B_0x0: [0, TX/RX pins are used as defined in standard pinout]
      B_0x1: [1, The TX and RX pins functions are swapped. This enables to work in the case of a cross-wired connection to another UART.]
    RXINV:
      B_0x0: [0, "RX pin signal works using the standard logic levels (V<sub>DD</sub> =1/idle, Gnd = 0/mark)"]
      B_0x1: [1, "RX pin signal values are inverted (V<sub>DD</sub> =0/mark, Gnd = 1/idle)."]
    TXINV:
      B_0x0: [0, "TX pin signal works using the standard logic levels (V<sub>DD</sub> =1/idle, Gnd = 0/mark)"]
      B_0x1: [1, "TX pin signal values are inverted (V<sub>DD</sub> =0/mark, Gnd = 1/idle)."]
    DATAINV:
      B_0x0: [0, "Logical data from the data register are send/received in positive/direct logic. (1 = H, 0 = L)"]
      B_0x1: [1, "Logical data from the data register are send/received in negative/inverse logic. (1 = L, 0 = H). The parity bit is also inverted."]
    MSBFIRST:
      B_0x0: [0, "data is transmitted/received with data bit 0 first, following the start bit."]
      B_0x1: [1, "data is transmitted/received with the MSB (bit 7/8) first, following the start bit."]
    ABREN:
      B_0x0: [0, Auto baud rate detection is disabled.]
      B_0x1: [1, Auto baud rate detection is enabled.]
    ABRMOD:
      B_0x0: [0, Measurement of the start bit is used to detect the baud rate.]
      B_0x1: [1, Falling edge to falling edge measurement (the received frame must start with a single bit = 1 and Frame = Start10xxxxxx)]
      B_0x2: [2, "0x7F frame detection."]
      B_0x3: [3, "0x55 frame detection"]
    RTOEN:
      B_0x0: [0, Receiver timeout feature disabled.]
      B_0x1: [1, Receiver timeout feature enabled.]
  USART_CR3:
    EIE:
      B_0x0: [0, Interrupt inhibited]
      B_0x1: [1, interrupt generated when FE = 1 or ORE = 1 or NE = 1 or UDR = 1 (in SPI slave mode) in the USART_ISR register.]
    IREN:
      B_0x0: [0, IrDA disabled]
      B_0x1: [1, IrDA enabled]
    IRLP:
      B_0x0: [0, Normal mode]
      B_0x1: [1, Low-power mode]
    HDSEL:
      B_0x0: [0, Half duplex mode is not selected]
      B_0x1: [1, Half duplex mode is selected]
    NACK:
      B_0x0: [0, NACK transmission in case of parity error is disabled]
      B_0x1: [1, NACK transmission during parity error is enabled]
    SCEN:
      B_0x0: [0, Smartcard Mode disabled]
      B_0x1: [1, Smartcard Mode enabled]
    DMAR:
      B_0x1: [1, DMA mode is enabled for reception]
      B_0x0: [0, DMA mode is disabled for reception]
    DMAT:
      B_0x1: [1, DMA mode is enabled for transmission]
      B_0x0: [0, DMA mode is disabled for transmission]
    RTSE:
      B_0x0: [0, RTS hardware flow control disabled]
      B_0x1: [1, "RTS output enabled, data is only requested when there is space in the receive buffer. The transmission of data is expected to cease after the current character has been transmitted. The RTS output is deasserted (pulled to 0) when data can be received."]
    CTSE:
      B_0x0: [0, CTS hardware flow control disabled]
      B_0x1: [1, "CTS mode enabled, data is only transmitted when the CTS input is deasserted (tied to 0). If the CTS input is asserted while data is being transmitted, then the transmission is completed before stopping. If data is written into the data register while CTS is asserted, the transmission is postponed until CTS is deasserted."]
    CTSIE:
      B_0x0: [0, Interrupt is inhibited]
      B_0x1: [1, An interrupt is generated whenever CTSIF = 1 in the USART_ISR register]
    ONEBIT:
      B_0x0: [0, Three sample bit method]
      B_0x1: [1, One sample bit method]
    OVRDIS:
      B_0x0: [0, "Overrun Error Flag, ORE, is set when received data is not read before receiving new data."]
      B_0x1: [1, Overrun functionality is disabled. If new data is received while the RXNE flag is still set]
    DDRE:
      B_0x0: [0, "DMA is not disabled in case of reception error. The corresponding error flag is set but RXNE is kept 0 preventing from overrun. As a consequence, the DMA request is not asserted, so the erroneous data is not transferred (no DMA request), but next correct received data is transferred (used for Smartcard mode)."]
      B_0x1: [1, "DMA is disabled following a reception error. The corresponding error flag is set, as well as RXNE. The DMA request is masked until the error flag is cleared. This means that the software must first disable the DMA request (DMAR = 0) or clear RXNE/RXFNE is case FIFO mode is enabled) before clearing the error flag."]
    DEM:
      B_0x0: [0, DE function is disabled.]
      B_0x1: [1, DE function is enabled. The DE signal is output on the RTS pin.]
    DEP:
      B_0x0: [0, DE signal is active high.]
      B_0x1: [1, DE signal is active low.]
    SCARCNT:
      B_0x0: [0, retransmission disabled - No automatic retransmission in transmit mode.]
    WUS:
      B_0x0: [0, "WUF active on address match (as defined by ADD[7:0] and ADDM7)"]
      B_0x2: [2, WUF active on start bit detection]
      B_0x3: [3, WUF active on RXNE/RXFNE.]
    WUFIE:
      B_0x0: [0, Interrupt inhibited]
      B_0x1: [1, USART interrupt generated whenever WUF = 1 in the USART_ISR register]
    TXFTIE:
      B_0x0: [0, Interrupt inhibited]
      B_0x1: [1, USART interrupt generated when TXFIFO reaches the threshold programmed in TXFTCFG.]
    TCBGTIE:
      B_0x0: [0, Interrupt inhibited]
      B_0x1: [1, USART interrupt generated whenever TCBGT=1 in the USART_ISR register]
    RXFTCFG:
      B_0x0: [0, Receive FIFO reaches 1/8 of its depth]
      B_0x1: [1, Receive FIFO reaches 1/4 of its depth]
      B_0x2: [2, Receive FIFO reaches 1/2 of its depth]
      B_0x3: [3, Receive FIFO reaches 3/4 of its depth]
      B_0x4: [4, Receive FIFO reaches 7/8 of its depth]
      B_0x5: [5, Receive FIFO becomes full]
    RXFTIE:
      B_0x0: [0, Interrupt inhibited]
      B_0x1: [1, USART interrupt generated when Receive FIFO reaches the threshold programmed in RXFTCFG.]
    TXFTCFG:
      B_0x0: [0, TXFIFO reaches 1/8 of its depth]
      B_0x1: [1, TXFIFO reaches 1/4 of its depth]
      B_0x2: [2, TXFIFO reaches 1/2 of its depth]
      B_0x3: [3, TXFIFO reaches 3/4 of its depth]
      B_0x4: [4, TXFIFO reaches 7/8 of its depth]
      B_0x5: [5, TXFIFO becomes empty]
  USART_GTPR:
    PSC:
      B_0x0: [0, Reserved - do not program this value]
      B_0x1: [1, Divides the source clock by 1 (IrDA mode) / by 2 (Smarcard mode)]
      B_0x2: [2, Divides the source clock by 2 (IrDA mode) / by 4 (Smartcard mode)]
      B_0x3: [3, Divides the source clock by 3 (IrDA mode) / by 6 (Smartcard mode)]
      B_0x1F: [31, Divides the source clock by 31 (IrDA mode) / by 62 (Smartcard mode)]
      B_0x20: [32, Divides the source clock by 32 (IrDA mode)]
      B_0xFF: [255, Divides the source clock by 255 (IrDA mode)]
  USART_ISR:
    PE:
      B_0x0: [0, No parity error]
      B_0x1: [1, Parity error]
    FE:
      B_0x0: [0, No Framing error is detected]
      B_0x1: [1, Framing error or break character is detected]
    NE:
      B_0x0: [0, No noise is detected]
      B_0x1: [1, Noise is detected]
    ORE:
      B_0x0: [0, No overrun error]
      B_0x1: [1, Overrun error is detected]
    IDLE:
      B_0x0: [0, No Idle line is detected]
      B_0x1: [1, Idle line is detected]
    RXFNE:
      B_0x0: [0, Data is not received]
      B_0x1: [1, Received data is ready to be read.]
    TC:
      B_0x0: [0, Transmission is not complete]
      B_0x1: [1, Transmission is complete]
    TXFNF:
      B_0x0: [0, Transmit FIFO is full]
      B_0x1: [1, Transmit FIFO is not full]
    LBDF:
      B_0x0: [0, LIN Break not detected]
      B_0x1: [1, LIN break detected]
    CTSIF:
      B_0x0: [0, No change occurred on the CTS status line]
      B_0x1: [1, A change occurred on the CTS status line]
    CTS:
      B_0x0: [0, CTS line set]
      B_0x1: [1, CTS line reset]
    RTOF:
      B_0x0: [0, Timeout value not reached]
      B_0x1: [1, Timeout value reached without any data reception]
    EOBF:
      B_0x0: [0, End of Block not reached]
      B_0x1: [1, End of Block (number of characters) reached]
    UDR:
      B_0x0: [0, No underrun error]
      B_0x1: [1, underrun error]
    BUSY:
      B_0x0: [0, USART is idle (no reception)]
      B_0x1: [1, Reception on going]
    CMF:
      B_0x0: [0, No Character match detected]
      B_0x1: [1, Character Match detected]
    SBKF:
      B_0x0: [0, Break character transmitted]
      B_0x1: [1, Break character requested by setting SBKRQ bit in USART_RQR register]
    RWU:
      B_0x0: [0, Receiver in active mode]
      B_0x1: [1, Receiver in Mute mode]
    TXFE:
      B_0x0: [0, TXFIFO not empty.]
      B_0x1: [1, TXFIFO empty.]
    RXFF:
      B_0x0: [0, RXFIFO not full.]
      B_0x1: [1, RXFIFO Full.]
    TCBGT:
      B_0x0: [0, Transmission is not complete or transmission is complete unsuccessfully (i.e. a NACK is received from the card)]
      B_0x1: [1, Transmission is complete successfully (before Guard time completion and there is no NACK from the smart card).]
    RXFT:
      B_0x0: [0, Receive FIFO does not reach the programmed threshold.]
      B_0x1: [1, Receive FIFO reached the programmed threshold.]
    TXFT:
      B_0x0: [0, TXFIFO does not reach the programmed threshold.]
      B_0x1: [1, TXFIFO reached the programmed threshold.]
  USART_ISR_ALTERNATE:
    PE:
      B_0x0: [0, No parity error]
      B_0x1: [1, Parity error]
    FE:
      B_0x0: [0, No Framing error is detected]
      B_0x1: [1, Framing error or break character is detected]
    NE:
      B_0x0: [0, No noise is detected]
      B_0x1: [1, Noise is detected]
    ORE:
      B_0x0: [0, No overrun error]
      B_0x1: [1, Overrun error is detected]
    IDLE:
      B_0x0: [0, No Idle line is detected]
      B_0x1: [1, Idle line is detected]
    RXNE:
      B_0x0: [0, Data is not received]
      B_0x1: [1, Received data is ready to be read.]
    TC:
      B_0x0: [0, Transmission is not complete]
      B_0x1: [1, Transmission is complete]
    TXE:
      B_0x0: [0, Data register full]
      B_0x1: [1, Data register not full]
    LBDF:
      B_0x0: [0, LIN Break not detected]
      B_0x1: [1, LIN break detected]
    CTSIF:
      B_0x0: [0, No change occurred on the CTS status line]
      B_0x1: [1, A change occurred on the CTS status line]
    CTS:
      B_0x0: [0, CTS line set]
      B_0x1: [1, CTS line reset]
    RTOF:
      B_0x0: [0, Timeout value not reached]
      B_0x1: [1, Timeout value reached without any data reception]
    EOBF:
      B_0x0: [0, End of Block not reached]
      B_0x1: [1, End of Block (number of characters) reached]
    UDR:
      B_0x0: [0, No underrun error]
      B_0x1: [1, underrun error]
    BUSY:
      B_0x0: [0, USART is idle (no reception)]
      B_0x1: [1, Reception on going]
    CMF:
      B_0x0: [0, No Character match detected]
      B_0x1: [1, Character Match detected]
    SBKF:
      B_0x0: [0, Break character transmitted]
      B_0x1: [1, Break character requested by setting SBKRQ bit in USART_RQR register]
    RWU:
      B_0x0: [0, Receiver in active mode]
      B_0x1: [1, Receiver in Mute mode]
    TCBGT:
      B_0x0: [0, Transmission is not complete or transmission is complete unsuccessfully (i.e. a NACK is received from the card)]
      B_0x1: [1, Transmission is complete successfully (before Guard time completion and there is no NACK from the smart card).]
  USART_PRESC:
    PRESCALER:
      B_0x0: [0, input clock not divided]
      B_0x1: [1, input clock divided by 2]
      B_0x2: [2, input clock divided by 4]
      B_0x3: [3, input clock divided by 6]
      B_0x4: [4, input clock divided by 8]
      B_0x5: [5, input clock divided by 10]
      B_0x6: [6, input clock divided by 12]
      B_0x7: [7, input clock divided by 16]
      B_0x8: [8, input clock divided by 32]
      B_0x9: [9, input clock divided by 64]
      B_0xA: [10, input clock divided by 128]
      B_0xB: [11, input clock divided by 256]
LPUART1:
  LPUART_CR1:
    UE:
      B_0x0: [0, "LPUART prescaler and outputs disabled, low-power mode"]
      B_0x1: [1, LPUART enabled]
    UESM:
      B_0x0: [0, LPUART not able to wake up the MCU from low-power mode.]
      B_0x1: [1, "LPUART able to wake up the MCU from low-power mode. When this function is active, the clock source for the LPUART must be HSI or LSE (see RCC chapter)"]
    RE:
      B_0x0: [0, Receiver is disabled]
      B_0x1: [1, Receiver is enabled and begins searching for a start bit]
    TE:
      B_0x0: [0, Transmitter is disabled]
      B_0x1: [1, Transmitter is enabled]
    IDLEIE:
      B_0x0: [0, Interrupt is inhibited]
      B_0x1: [1, An LPUART interrupt is generated whenever IDLE = 1 in the LPUART_ISR register]
    RXFNEIE:
      B_0x0: [0, Interrupt is inhibited]
      B_0x1: [1, A LPUART interrupt is generated whenever ORE = 1 or RXNE/RXFNE = 1 in the LPUART_ISR register]
    TCIE:
      B_0x0: [0, Interrupt is inhibited]
      B_0x1: [1, An LPUART interrupt is generated whenever TC = 1 in the LPUART_ISR register]
    TXFNFIE:
      B_0x0: [0, Interrupt is inhibited]
      B_0x1: [1, A LPUART interrupt is generated whenever TXE/TXFNF =1 in the LPUART_ISR register]
    PEIE:
      B_0x0: [0, Interrupt is inhibited]
      B_0x1: [1, An LPUART interrupt is generated whenever PE = 1 in the LPUART_ISR register]
    PS:
      B_0x0: [0, Even parity]
      B_0x1: [1, Odd parity]
    PCE:
      B_0x0: [0, Parity control disabled]
      B_0x1: [1, Parity control enabled]
    WAKE:
      B_0x0: [0, Idle line]
      B_0x1: [1, Address mark]
    MME:
      B_0x0: [0, Receiver in active mode permanently]
      B_0x1: [1, Receiver can switch between Mute mode and active mode.]
    CMIE:
      B_0x0: [0, Interrupt is inhibited]
      B_0x1: [1, A LPUART interrupt is generated when the CMF bit is set in the LPUART_ISR register.]
    FIFOEN:
      B_0x0: [0, FIFO mode is disabled.]
      B_0x1: [1, FIFO mode is enabled.]
    TXFEIE:
      B_0x0: [0, Interrupt is inhibited]
      B_0x1: [1, An LPUART interrupt is generated when TXFE = 1 in the LPUART_ISR register]
    RXFFIE:
      B_0x0: [0, Interrupt is inhibited]
      B_0x1: [1, An LPUART interrupt is generated when RXFF = 1 in the LPUART_ISR register]
  LPUART_CR1_ALTERNATE:
    UE:
      B_0x0: [0, "LPUART prescaler and outputs disabled, low-power mode"]
      B_0x1: [1, LPUART enabled]
    UESM:
      B_0x0: [0, LPUART not able to wake up the MCU from low-power mode.]
      B_0x1: [1, "LPUART able to wake up the MCU from low-power mode. When this function is active, the clock source for the LPUART must be HSI or LSE (see RCC chapter)"]
    RE:
      B_0x0: [0, Receiver is disabled]
      B_0x1: [1, Receiver is enabled and begins searching for a start bit]
    TE:
      B_0x0: [0, Transmitter is disabled]
      B_0x1: [1, Transmitter is enabled]
    IDLEIE:
      B_0x0: [0, Interrupt is inhibited]
      B_0x1: [1, An LPUART interrupt is generated whenever IDLE = 1 in the LPUART_ISR register]
    RXNEIE:
      B_0x0: [0, Interrupt is inhibited]
      B_0x1: [1, A LPUART interrupt is generated whenever ORE = 1 or RXNE/RXFNE = 1 in the LPUART_ISR register]
    TCIE:
      B_0x0: [0, Interrupt is inhibited]
      B_0x1: [1, An LPUART interrupt is generated whenever TC = 1 in the LPUART_ISR register]
    TXEIE:
      B_0x0: [0, Interrupt is inhibited]
      B_0x1: [1, A LPUART interrupt is generated whenever TXE/TXFNF =1 in the LPUART_ISR register]
    PEIE:
      B_0x0: [0, Interrupt is inhibited]
      B_0x1: [1, An LPUART interrupt is generated whenever PE = 1 in the LPUART_ISR register]
    PS:
      B_0x0: [0, Even parity]
      B_0x1: [1, Odd parity]
    PCE:
      B_0x0: [0, Parity control disabled]
      B_0x1: [1, Parity control enabled]
    WAKE:
      B_0x0: [0, Idle line]
      B_0x1: [1, Address mark]
    MME:
      B_0x0: [0, Receiver in active mode permanently]
      B_0x1: [1, Receiver can switch between Mute mode and active mode.]
    CMIE:
      B_0x0: [0, Interrupt is inhibited]
      B_0x1: [1, A LPUART interrupt is generated when the CMF bit is set in the LPUART_ISR register.]
    FIFOEN:
      B_0x0: [0, FIFO mode is disabled.]
      B_0x1: [1, FIFO mode is enabled.]
  LPUART_CR2:
    ADDM7:
      B_0x0: [0, 4-bit address detection]
      B_0x1: [1, 7-bit address detection (in 8-bit data mode)]
    STOP:
      B_0x0: [0, 1 stop bit]
      B_0x2: [2, 2 stop bits]
    SWAP:
      B_0x0: [0, TX/RX pins are used as defined in standard pinout]
      B_0x1: [1, The TX and RX pins functions are swapped. This enables to work in the case of a cross-wired connection to another UART.]
    RXINV:
      B_0x0: [0, "RX pin signal works using the standard logic levels (V<sub>DD</sub> = 1/idle, Gnd = 0/mark)"]
      B_0x1: [1, "RX pin signal values are inverted (V<sub>DD</sub> = 0/mark, Gnd = 1/idle)."]
    TXINV:
      B_0x0: [0, "TX pin signal works using the standard logic levels (V<sub>DD</sub> = 1/idle, Gnd = 0/mark)"]
      B_0x1: [1, "TX pin signal values are inverted (V<sub>DD</sub> = 0/mark, Gnd = 1/idle)."]
    DATAINV:
      B_0x0: [0, "Logical data from the data register are send/received in positive/direct logic. (1 = H, 0 = L)"]
      B_0x1: [1, "Logical data from the data register are send/received in negative/inverse logic. (1 = L, 0 = H). The parity bit is also inverted."]
    MSBFIRST:
      B_0x0: [0, "data is transmitted/received with data bit 0 first, following the start bit."]
      B_0x1: [1, "data is transmitted/received with the MSB (bit 7/8) first, following the start bit."]
  LPUART_CR3:
    EIE:
      B_0x0: [0, Interrupt is inhibited]
      B_0x1: [1, An interrupt is generated when FE = 1 or ORE = 1 or NE = 1 in the LPUART_ISR register.]
    HDSEL:
      B_0x0: [0, Half duplex mode is not selected]
      B_0x1: [1, Half duplex mode is selected]
    DMAR:
      B_0x1: [1, DMA mode is enabled for reception]
      B_0x0: [0, DMA mode is disabled for reception]
    DMAT:
      B_0x1: [1, DMA mode is enabled for transmission]
      B_0x0: [0, DMA mode is disabled for transmission]
    RTSE:
      B_0x0: [0, RTS hardware flow control disabled]
      B_0x1: [1, "RTS output enabled, data is only requested when there is space in the receive buffer. The transmission of data is expected to cease after the current character has been transmitted. The RTS output is deasserted (pulled to 0) when data can be received."]
    CTSE:
      B_0x0: [0, CTS hardware flow control disabled]
      B_0x1: [1, "CTS mode enabled, data is only transmitted when the CTS input is deasserted (tied to 0). If the CTS input is asserted while data is being transmitted, then the transmission is completed before stopping. If data is written into the data register while CTS is asserted, the transmission is postponed until CTS is deasserted."]
    CTSIE:
      B_0x0: [0, Interrupt is inhibited]
      B_0x1: [1, An interrupt is generated whenever CTSIF = 1 in the LPUART_ISR register]
    OVRDIS:
      B_0x0: [0, "Overrun Error Flag, ORE is set when received data is not read before receiving new data."]
      B_0x1: [1, Overrun functionality is disabled. If new data is received while the RXNE flag is still set]
    DDRE:
      B_0x0: [0, "DMA is not disabled in case of reception error. The corresponding error flag is set but RXNE is kept 0 preventing from overrun. As a consequence, the DMA request is not asserted, so the erroneous data is not transferred (no DMA request), but next correct received data is transferred."]
      B_0x1: [1, "DMA is disabled following a reception error. The corresponding error flag is set, as well as RXNE. The DMA request is masked until the error flag is cleared. This means that the software must first disable the DMA request (DMAR = 0) or clear RXNE before clearing the error flag."]
    DEM:
      B_0x0: [0, DE function is disabled.]
      B_0x1: [1, DE function is enabled. The DE signal is output on the RTS pin.]
    DEP:
      B_0x0: [0, DE signal is active high.]
      B_0x1: [1, DE signal is active low.]
    WUS:
      B_0x0: [0, "WUF active on address match (as defined by ADD[7:0] and ADDM7)"]
      B_0x2: [2, WUF active on Start bit detection]
      B_0x3: [3, WUF active on RXNE.]
    WUFIE:
      B_0x0: [0, Interrupt is inhibited]
      B_0x1: [1, An LPUART interrupt is generated whenever WUF = 1 in the LPUART_ISR register]
    TXFTIE:
      B_0x0: [0, Interrupt is inhibited]
      B_0x1: [1, A LPUART interrupt is generated when TXFIFO reaches the threshold programmed in TXFTCFG.]
    RXFTCFG:
      B_0x0: [0, Receive FIFO reaches 1/8 of its depth.]
      B_0x1: [1, Receive FIFO reaches 1/4 of its depth.]
      B_0x6: [6, Receive FIFO reaches 1/2 of its depth.]
      B_0x3: [3, Receive FIFO reaches 3/4 of its depth.]
      B_0x4: [4, Receive FIFO reaches 7/8 of its depth.]
      B_0x5: [5, Receive FIFO becomes full.]
    RXFTIE:
      B_0x0: [0, Interrupt is inhibited]
      B_0x1: [1, An LPUART interrupt is generated when Receive FIFO reaches the threshold programmed in RXFTCFG.]
    TXFTCFG:
      B_0x0: [0, TXFIFO reaches 1/8 of its depth.]
      B_0x1: [1, TXFIFO reaches 1/4 of its depth.]
      B_0x6: [6, TXFIFO reaches 1/2 of its depth.]
      B_0x3: [3, TXFIFO reaches 3/4 of its depth.]
      B_0x4: [4, TXFIFO reaches 7/8 of its depth.]
      B_0x5: [5, TXFIFO becomes empty.]
  LPUART_ISR:
    PE:
      B_0x0: [0, No parity error]
      B_0x1: [1, Parity error]
    FE:
      B_0x0: [0, No Framing error is detected]
      B_0x1: [1, Framing error or break character is detected]
    NE:
      B_0x0: [0, No noise is detected]
      B_0x1: [1, Noise is detected]
    ORE:
      B_0x0: [0, No overrun error]
      B_0x1: [1, Overrun error is detected]
    IDLE:
      B_0x0: [0, No Idle line is detected]
      B_0x1: [1, Idle line is detected]
    RXFNE:
      B_0x0: [0, Data is not received]
      B_0x1: [1, Received data is ready to be read.]
    TC:
      B_0x0: [0, Transmission is not complete]
      B_0x1: [1, Transmission is complete]
    TXFNF:
      B_0x0: [0, Data register is full/Transmit FIFO is full.]
      B_0x1: [1, Data register/Transmit FIFO is not full.]
    CTSIF:
      B_0x0: [0, No change occurred on the CTS status line]
      B_0x1: [1, A change occurred on the CTS status line]
    CTS:
      B_0x0: [0, CTS line set]
      B_0x1: [1, CTS line reset]
    BUSY:
      B_0x0: [0, LPUART is idle (no reception)]
      B_0x1: [1, Reception on going]
    CMF:
      B_0x0: [0, No Character match detected]
      B_0x1: [1, Character Match detected]
    SBKF:
      B_0x0: [0, Break character transmitted]
      B_0x1: [1, Break character requested by setting SBKRQ bit in LPUART_RQR register]
    RWU:
      B_0x0: [0, Receiver in Active mode]
      B_0x1: [1, Receiver in Mute mode]
    TXFE:
      B_0x0: [0, TXFIFO is not empty]
      B_0x1: [1, TXFIFO is empty]
    RXFF:
      B_0x0: [0, RXFIFO is not full]
      B_0x1: [1, RXFIFO is full]
    RXFT:
      B_0x0: [0, Receive FIFO does not reach the programmed threshold.]
      B_0x1: [1, Receive FIFO reached the programmed threshold.]
    TXFT:
      B_0x0: [0, TXFIFO does not reach the programmed threshold.]
      B_0x1: [1, TXFIFO reached the programmed threshold.]
  LPUART_ISR_ALTERNATE:
    PE:
      B_0x0: [0, No parity error]
      B_0x1: [1, Parity error]
    FE:
      B_0x0: [0, No Framing error is detected]
      B_0x1: [1, Framing error or break character is detected]
    NE:
      B_0x0: [0, No noise is detected]
      B_0x1: [1, Noise is detected]
    ORE:
      B_0x0: [0, No overrun error]
      B_0x1: [1, Overrun error is detected]
    IDLE:
      B_0x0: [0, No Idle line is detected]
      B_0x1: [1, Idle line is detected]
    RXNE:
      B_0x0: [0, Data is not received]
      B_0x1: [1, Received data is ready to be read.]
    TC:
      B_0x0: [0, Transmission is not complete]
      B_0x1: [1, Transmission is complete]
    TXE:
      B_0x0: [0, Data register full]
      B_0x1: [1, Data register not full]
    CTSIF:
      B_0x0: [0, No change occurred on the CTS status line]
      B_0x1: [1, A change occurred on the CTS status line]
    CTS:
      B_0x0: [0, CTS line set]
      B_0x1: [1, CTS line reset]
    BUSY:
      B_0x0: [0, LPUART is idle (no reception)]
      B_0x1: [1, Reception on going]
    CMF:
      B_0x0: [0, No Character match detected]
      B_0x1: [1, Character Match detected]
    SBKF:
      B_0x0: [0, Break character transmitted]
      B_0x1: [1, Break character requested by setting SBKRQ bit in LPUART_RQR register]
    RWU:
      B_0x0: [0, Receiver in active mode]
      B_0x1: [1, Receiver in Mute mode]
  LPUART_PRESC:
    PRESCALER:
      B_0x0: [0, input clock not divided]
      B_0x1: [1, input clock divided by 2]
      B_0x2: [2, input clock divided by 4]
      B_0x3: [3, input clock divided by 6]
      B_0x4: [4, input clock divided by 8]
      B_0x5: [5, input clock divided by 10]
      B_0x6: [6, input clock divided by 12]
      B_0x7: [7, input clock divided by 16]
      B_0x8: [8, input clock divided by 32]
      B_0x9: [9, input clock divided by 64]
      B_0xA: [10, input clock divided by 128]
      B_0xB: [11, input clock divided by 256]